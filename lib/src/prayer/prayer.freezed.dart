// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'prayer.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

PrayerTime _$PrayerTimeFromJson(Map<String, dynamic> json) {
  return _PrayerTime.fromJson(json);
}

/// @nodoc
class _$PrayerTimeTearOff {
  const _$PrayerTimeTearOff();

  _PrayerTime call(
      {String? isha,
      String? maghrib,
      String? sunrise,
      String? zuhr,
      String? asr,
      String? date,
      String? fajr}) {
    return _PrayerTime(
      isha: isha,
      maghrib: maghrib,
      sunrise: sunrise,
      zuhr: zuhr,
      asr: asr,
      date: date,
      fajr: fajr,
    );
  }

  PrayerTime fromJson(Map<String, Object?> json) {
    return PrayerTime.fromJson(json);
  }
}

/// @nodoc
const $PrayerTime = _$PrayerTimeTearOff();

/// @nodoc
mixin _$PrayerTime {
  /// isha time
  String? get isha => throw _privateConstructorUsedError;

  /// maghrib time
  String? get maghrib => throw _privateConstructorUsedError;

  /// time of sunrise
  String? get sunrise => throw _privateConstructorUsedError;

  /// zuhr time
  String? get zuhr => throw _privateConstructorUsedError;

  /// asr time
  String? get asr => throw _privateConstructorUsedError;

  /// date for prayer times in YYYY-MM-DD format
  String? get date => throw _privateConstructorUsedError;

  /// fajr time
  String? get fajr => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PrayerTimeCopyWith<PrayerTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PrayerTimeCopyWith<$Res> {
  factory $PrayerTimeCopyWith(
          PrayerTime value, $Res Function(PrayerTime) then) =
      _$PrayerTimeCopyWithImpl<$Res>;
  $Res call(
      {String? isha,
      String? maghrib,
      String? sunrise,
      String? zuhr,
      String? asr,
      String? date,
      String? fajr});
}

/// @nodoc
class _$PrayerTimeCopyWithImpl<$Res> implements $PrayerTimeCopyWith<$Res> {
  _$PrayerTimeCopyWithImpl(this._value, this._then);

  final PrayerTime _value;
  // ignore: unused_field
  final $Res Function(PrayerTime) _then;

  @override
  $Res call({
    Object? isha = freezed,
    Object? maghrib = freezed,
    Object? sunrise = freezed,
    Object? zuhr = freezed,
    Object? asr = freezed,
    Object? date = freezed,
    Object? fajr = freezed,
  }) {
    return _then(_value.copyWith(
      isha: isha == freezed
          ? _value.isha
          : isha // ignore: cast_nullable_to_non_nullable
              as String?,
      maghrib: maghrib == freezed
          ? _value.maghrib
          : maghrib // ignore: cast_nullable_to_non_nullable
              as String?,
      sunrise: sunrise == freezed
          ? _value.sunrise
          : sunrise // ignore: cast_nullable_to_non_nullable
              as String?,
      zuhr: zuhr == freezed
          ? _value.zuhr
          : zuhr // ignore: cast_nullable_to_non_nullable
              as String?,
      asr: asr == freezed
          ? _value.asr
          : asr // ignore: cast_nullable_to_non_nullable
              as String?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      fajr: fajr == freezed
          ? _value.fajr
          : fajr // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$PrayerTimeCopyWith<$Res> implements $PrayerTimeCopyWith<$Res> {
  factory _$PrayerTimeCopyWith(
          _PrayerTime value, $Res Function(_PrayerTime) then) =
      __$PrayerTimeCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? isha,
      String? maghrib,
      String? sunrise,
      String? zuhr,
      String? asr,
      String? date,
      String? fajr});
}

/// @nodoc
class __$PrayerTimeCopyWithImpl<$Res> extends _$PrayerTimeCopyWithImpl<$Res>
    implements _$PrayerTimeCopyWith<$Res> {
  __$PrayerTimeCopyWithImpl(
      _PrayerTime _value, $Res Function(_PrayerTime) _then)
      : super(_value, (v) => _then(v as _PrayerTime));

  @override
  _PrayerTime get _value => super._value as _PrayerTime;

  @override
  $Res call({
    Object? isha = freezed,
    Object? maghrib = freezed,
    Object? sunrise = freezed,
    Object? zuhr = freezed,
    Object? asr = freezed,
    Object? date = freezed,
    Object? fajr = freezed,
  }) {
    return _then(_PrayerTime(
      isha: isha == freezed
          ? _value.isha
          : isha // ignore: cast_nullable_to_non_nullable
              as String?,
      maghrib: maghrib == freezed
          ? _value.maghrib
          : maghrib // ignore: cast_nullable_to_non_nullable
              as String?,
      sunrise: sunrise == freezed
          ? _value.sunrise
          : sunrise // ignore: cast_nullable_to_non_nullable
              as String?,
      zuhr: zuhr == freezed
          ? _value.zuhr
          : zuhr // ignore: cast_nullable_to_non_nullable
              as String?,
      asr: asr == freezed
          ? _value.asr
          : asr // ignore: cast_nullable_to_non_nullable
              as String?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
      fajr: fajr == freezed
          ? _value.fajr
          : fajr // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PrayerTime implements _PrayerTime {
  const _$_PrayerTime(
      {this.isha,
      this.maghrib,
      this.sunrise,
      this.zuhr,
      this.asr,
      this.date,
      this.fajr});

  factory _$_PrayerTime.fromJson(Map<String, dynamic> json) =>
      _$$_PrayerTimeFromJson(json);

  @override

  /// isha time
  final String? isha;
  @override

  /// maghrib time
  final String? maghrib;
  @override

  /// time of sunrise
  final String? sunrise;
  @override

  /// zuhr time
  final String? zuhr;
  @override

  /// asr time
  final String? asr;
  @override

  /// date for prayer times in YYYY-MM-DD format
  final String? date;
  @override

  /// fajr time
  final String? fajr;

  @override
  String toString() {
    return 'PrayerTime(isha: $isha, maghrib: $maghrib, sunrise: $sunrise, zuhr: $zuhr, asr: $asr, date: $date, fajr: $fajr)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PrayerTime &&
            const DeepCollectionEquality().equals(other.isha, isha) &&
            const DeepCollectionEquality().equals(other.maghrib, maghrib) &&
            const DeepCollectionEquality().equals(other.sunrise, sunrise) &&
            const DeepCollectionEquality().equals(other.zuhr, zuhr) &&
            const DeepCollectionEquality().equals(other.asr, asr) &&
            const DeepCollectionEquality().equals(other.date, date) &&
            const DeepCollectionEquality().equals(other.fajr, fajr));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isha),
      const DeepCollectionEquality().hash(maghrib),
      const DeepCollectionEquality().hash(sunrise),
      const DeepCollectionEquality().hash(zuhr),
      const DeepCollectionEquality().hash(asr),
      const DeepCollectionEquality().hash(date),
      const DeepCollectionEquality().hash(fajr));

  @JsonKey(ignore: true)
  @override
  _$PrayerTimeCopyWith<_PrayerTime> get copyWith =>
      __$PrayerTimeCopyWithImpl<_PrayerTime>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PrayerTimeToJson(this);
  }
}

abstract class _PrayerTime implements PrayerTime {
  const factory _PrayerTime(
      {String? isha,
      String? maghrib,
      String? sunrise,
      String? zuhr,
      String? asr,
      String? date,
      String? fajr}) = _$_PrayerTime;

  factory _PrayerTime.fromJson(Map<String, dynamic> json) =
      _$_PrayerTime.fromJson;

  @override

  /// isha time
  String? get isha;
  @override

  /// maghrib time
  String? get maghrib;
  @override

  /// time of sunrise
  String? get sunrise;
  @override

  /// zuhr time
  String? get zuhr;
  @override

  /// asr time
  String? get asr;
  @override

  /// date for prayer times in YYYY-MM-DD format
  String? get date;
  @override

  /// fajr time
  String? get fajr;
  @override
  @JsonKey(ignore: true)
  _$PrayerTimeCopyWith<_PrayerTime> get copyWith =>
      throw _privateConstructorUsedError;
}

TimesRequest _$TimesRequestFromJson(Map<String, dynamic> json) {
  return _TimesRequest.fromJson(json);
}

/// @nodoc
class _$TimesRequestTearOff {
  const _$TimesRequestTearOff();

  _TimesRequest call(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      String? date}) {
    return _TimesRequest(
      days: days,
      latitude: latitude,
      location: location,
      longitude: longitude,
      date: date,
    );
  }

  TimesRequest fromJson(Map<String, Object?> json) {
    return TimesRequest.fromJson(json);
  }
}

/// @nodoc
const $TimesRequest = _$TimesRequestTearOff();

/// @nodoc
mixin _$TimesRequest {
  /// number of days to request times for
  int? get days => throw _privateConstructorUsedError;

  /// optional latitude used in place of location
  double? get latitude => throw _privateConstructorUsedError;

  /// location to retrieve prayer times for.
  /// this can be a specific address, city, etc
  String? get location => throw _privateConstructorUsedError;

  /// optional longitude used in place of location
  double? get longitude => throw _privateConstructorUsedError;

  /// optional date in YYYY-MM-DD format, otherwise uses today
  String? get date => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TimesRequestCopyWith<TimesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimesRequestCopyWith<$Res> {
  factory $TimesRequestCopyWith(
          TimesRequest value, $Res Function(TimesRequest) then) =
      _$TimesRequestCopyWithImpl<$Res>;
  $Res call(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      String? date});
}

/// @nodoc
class _$TimesRequestCopyWithImpl<$Res> implements $TimesRequestCopyWith<$Res> {
  _$TimesRequestCopyWithImpl(this._value, this._then);

  final TimesRequest _value;
  // ignore: unused_field
  final $Res Function(TimesRequest) _then;

  @override
  $Res call({
    Object? days = freezed,
    Object? latitude = freezed,
    Object? location = freezed,
    Object? longitude = freezed,
    Object? date = freezed,
  }) {
    return _then(_value.copyWith(
      days: days == freezed
          ? _value.days
          : days // ignore: cast_nullable_to_non_nullable
              as int?,
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$TimesRequestCopyWith<$Res>
    implements $TimesRequestCopyWith<$Res> {
  factory _$TimesRequestCopyWith(
          _TimesRequest value, $Res Function(_TimesRequest) then) =
      __$TimesRequestCopyWithImpl<$Res>;
  @override
  $Res call(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      String? date});
}

/// @nodoc
class __$TimesRequestCopyWithImpl<$Res> extends _$TimesRequestCopyWithImpl<$Res>
    implements _$TimesRequestCopyWith<$Res> {
  __$TimesRequestCopyWithImpl(
      _TimesRequest _value, $Res Function(_TimesRequest) _then)
      : super(_value, (v) => _then(v as _TimesRequest));

  @override
  _TimesRequest get _value => super._value as _TimesRequest;

  @override
  $Res call({
    Object? days = freezed,
    Object? latitude = freezed,
    Object? location = freezed,
    Object? longitude = freezed,
    Object? date = freezed,
  }) {
    return _then(_TimesRequest(
      days: days == freezed
          ? _value.days
          : days // ignore: cast_nullable_to_non_nullable
              as int?,
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TimesRequest implements _TimesRequest {
  const _$_TimesRequest(
      {this.days, this.latitude, this.location, this.longitude, this.date});

  factory _$_TimesRequest.fromJson(Map<String, dynamic> json) =>
      _$$_TimesRequestFromJson(json);

  @override

  /// number of days to request times for
  final int? days;
  @override

  /// optional latitude used in place of location
  final double? latitude;
  @override

  /// location to retrieve prayer times for.
  /// this can be a specific address, city, etc
  final String? location;
  @override

  /// optional longitude used in place of location
  final double? longitude;
  @override

  /// optional date in YYYY-MM-DD format, otherwise uses today
  final String? date;

  @override
  String toString() {
    return 'TimesRequest(days: $days, latitude: $latitude, location: $location, longitude: $longitude, date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TimesRequest &&
            const DeepCollectionEquality().equals(other.days, days) &&
            const DeepCollectionEquality().equals(other.latitude, latitude) &&
            const DeepCollectionEquality().equals(other.location, location) &&
            const DeepCollectionEquality().equals(other.longitude, longitude) &&
            const DeepCollectionEquality().equals(other.date, date));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(days),
      const DeepCollectionEquality().hash(latitude),
      const DeepCollectionEquality().hash(location),
      const DeepCollectionEquality().hash(longitude),
      const DeepCollectionEquality().hash(date));

  @JsonKey(ignore: true)
  @override
  _$TimesRequestCopyWith<_TimesRequest> get copyWith =>
      __$TimesRequestCopyWithImpl<_TimesRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TimesRequestToJson(this);
  }
}

abstract class _TimesRequest implements TimesRequest {
  const factory _TimesRequest(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      String? date}) = _$_TimesRequest;

  factory _TimesRequest.fromJson(Map<String, dynamic> json) =
      _$_TimesRequest.fromJson;

  @override

  /// number of days to request times for
  int? get days;
  @override

  /// optional latitude used in place of location
  double? get latitude;
  @override

  /// location to retrieve prayer times for.
  /// this can be a specific address, city, etc
  String? get location;
  @override

  /// optional longitude used in place of location
  double? get longitude;
  @override

  /// optional date in YYYY-MM-DD format, otherwise uses today
  String? get date;
  @override
  @JsonKey(ignore: true)
  _$TimesRequestCopyWith<_TimesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

TimesResponse _$TimesResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return TimesResponseData.fromJson(json);
    case 'Merr':
      return TimesResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'TimesResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
class _$TimesResponseTearOff {
  const _$TimesResponseTearOff();

  TimesResponseData call(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      List<PrayerTime>? times,
      String? date}) {
    return TimesResponseData(
      days: days,
      latitude: latitude,
      location: location,
      longitude: longitude,
      times: times,
      date: date,
    );
  }

  TimesResponseMerr Merr({Map<String, dynamic>? body}) {
    return TimesResponseMerr(
      body: body,
    );
  }

  TimesResponse fromJson(Map<String, Object?> json) {
    return TimesResponse.fromJson(json);
  }
}

/// @nodoc
const $TimesResponse = _$TimesResponseTearOff();

/// @nodoc
mixin _$TimesResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(TimesResponseData value) $default, {
    required TResult Function(TimesResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimesResponseCopyWith<$Res> {
  factory $TimesResponseCopyWith(
          TimesResponse value, $Res Function(TimesResponse) then) =
      _$TimesResponseCopyWithImpl<$Res>;
}

/// @nodoc
class _$TimesResponseCopyWithImpl<$Res>
    implements $TimesResponseCopyWith<$Res> {
  _$TimesResponseCopyWithImpl(this._value, this._then);

  final TimesResponse _value;
  // ignore: unused_field
  final $Res Function(TimesResponse) _then;
}

/// @nodoc
abstract class $TimesResponseDataCopyWith<$Res> {
  factory $TimesResponseDataCopyWith(
          TimesResponseData value, $Res Function(TimesResponseData) then) =
      _$TimesResponseDataCopyWithImpl<$Res>;
  $Res call(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      List<PrayerTime>? times,
      String? date});
}

/// @nodoc
class _$TimesResponseDataCopyWithImpl<$Res>
    extends _$TimesResponseCopyWithImpl<$Res>
    implements $TimesResponseDataCopyWith<$Res> {
  _$TimesResponseDataCopyWithImpl(
      TimesResponseData _value, $Res Function(TimesResponseData) _then)
      : super(_value, (v) => _then(v as TimesResponseData));

  @override
  TimesResponseData get _value => super._value as TimesResponseData;

  @override
  $Res call({
    Object? days = freezed,
    Object? latitude = freezed,
    Object? location = freezed,
    Object? longitude = freezed,
    Object? times = freezed,
    Object? date = freezed,
  }) {
    return _then(TimesResponseData(
      days: days == freezed
          ? _value.days
          : days // ignore: cast_nullable_to_non_nullable
              as int?,
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      times: times == freezed
          ? _value.times
          : times // ignore: cast_nullable_to_non_nullable
              as List<PrayerTime>?,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TimesResponseData implements TimesResponseData {
  const _$TimesResponseData(
      {this.days,
      this.latitude,
      this.location,
      this.longitude,
      this.times,
      this.date,
      String? $type})
      : $type = $type ?? 'default';

  factory _$TimesResponseData.fromJson(Map<String, dynamic> json) =>
      _$$TimesResponseDataFromJson(json);

  @override

  /// number of days
  final int? days;
  @override

  /// latitude of location
  final double? latitude;
  @override

  /// location for the request
  final String? location;
  @override

  /// longitude of location
  final double? longitude;
  @override

  /// prayer times for the given location
  final List<PrayerTime>? times;
  @override

  /// date of request
  final String? date;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'TimesResponse(days: $days, latitude: $latitude, location: $location, longitude: $longitude, times: $times, date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TimesResponseData &&
            const DeepCollectionEquality().equals(other.days, days) &&
            const DeepCollectionEquality().equals(other.latitude, latitude) &&
            const DeepCollectionEquality().equals(other.location, location) &&
            const DeepCollectionEquality().equals(other.longitude, longitude) &&
            const DeepCollectionEquality().equals(other.times, times) &&
            const DeepCollectionEquality().equals(other.date, date));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(days),
      const DeepCollectionEquality().hash(latitude),
      const DeepCollectionEquality().hash(location),
      const DeepCollectionEquality().hash(longitude),
      const DeepCollectionEquality().hash(times),
      const DeepCollectionEquality().hash(date));

  @JsonKey(ignore: true)
  @override
  $TimesResponseDataCopyWith<TimesResponseData> get copyWith =>
      _$TimesResponseDataCopyWithImpl<TimesResponseData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(days, latitude, location, longitude, times, date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(days, latitude, location, longitude, times, date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(days, latitude, location, longitude, times, date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(TimesResponseData value) $default, {
    required TResult Function(TimesResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$TimesResponseDataToJson(this);
  }
}

abstract class TimesResponseData implements TimesResponse {
  const factory TimesResponseData(
      {int? days,
      double? latitude,
      String? location,
      double? longitude,
      List<PrayerTime>? times,
      String? date}) = _$TimesResponseData;

  factory TimesResponseData.fromJson(Map<String, dynamic> json) =
      _$TimesResponseData.fromJson;

  /// number of days
  int? get days;

  /// latitude of location
  double? get latitude;

  /// location for the request
  String? get location;

  /// longitude of location
  double? get longitude;

  /// prayer times for the given location
  List<PrayerTime>? get times;

  /// date of request
  String? get date;
  @JsonKey(ignore: true)
  $TimesResponseDataCopyWith<TimesResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimesResponseMerrCopyWith<$Res> {
  factory $TimesResponseMerrCopyWith(
          TimesResponseMerr value, $Res Function(TimesResponseMerr) then) =
      _$TimesResponseMerrCopyWithImpl<$Res>;
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class _$TimesResponseMerrCopyWithImpl<$Res>
    extends _$TimesResponseCopyWithImpl<$Res>
    implements $TimesResponseMerrCopyWith<$Res> {
  _$TimesResponseMerrCopyWithImpl(
      TimesResponseMerr _value, $Res Function(TimesResponseMerr) _then)
      : super(_value, (v) => _then(v as TimesResponseMerr));

  @override
  TimesResponseMerr get _value => super._value as TimesResponseMerr;

  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(TimesResponseMerr(
      body: body == freezed
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TimesResponseMerr implements TimesResponseMerr {
  const _$TimesResponseMerr({this.body, String? $type})
      : $type = $type ?? 'Merr';

  factory _$TimesResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$TimesResponseMerrFromJson(json);

  @override
  final Map<String, dynamic>? body;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'TimesResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TimesResponseMerr &&
            const DeepCollectionEquality().equals(other.body, body));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(body));

  @JsonKey(ignore: true)
  @override
  $TimesResponseMerrCopyWith<TimesResponseMerr> get copyWith =>
      _$TimesResponseMerrCopyWithImpl<TimesResponseMerr>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? days, double? latitude, String? location,
            double? longitude, List<PrayerTime>? times, String? date)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(TimesResponseData value) $default, {
    required TResult Function(TimesResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(TimesResponseData value)? $default, {
    TResult Function(TimesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$TimesResponseMerrToJson(this);
  }
}

abstract class TimesResponseMerr implements TimesResponse {
  const factory TimesResponseMerr({Map<String, dynamic>? body}) =
      _$TimesResponseMerr;

  factory TimesResponseMerr.fromJson(Map<String, dynamic> json) =
      _$TimesResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  $TimesResponseMerrCopyWith<TimesResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}
