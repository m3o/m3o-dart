// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'quran.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Chapter _$ChapterFromJson(Map<String, dynamic> json) {
  return _Chapter.fromJson(json);
}

/// @nodoc
mixin _$Chapter {
  /// Should the chapter start with bismillah
  bool? get prefix_bismillah => throw _privateConstructorUsedError;

  /// The order in which it was revealed
  int? get revelation_order => throw _privateConstructorUsedError;

  /// The place of revelation
  String? get revelation_place => throw _privateConstructorUsedError;

  /// The arabic name of the chapter
  String? get arabic_name => throw _privateConstructorUsedError;

  /// The complex name of the chapter
  String? get complex_name => throw _privateConstructorUsedError;

  /// The pages from and to e.g 1, 1
  List<int>? get pages => throw _privateConstructorUsedError;

  /// The translated name
  String? get translated_name => throw _privateConstructorUsedError;

  /// The number of verses in the chapter
  int? get verses => throw _privateConstructorUsedError;

  /// The id of the chapter as a number e.g 1
  int? get id => throw _privateConstructorUsedError;

  /// The simple name of the chapter
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChapterCopyWith<Chapter> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChapterCopyWith<$Res> {
  factory $ChapterCopyWith(Chapter value, $Res Function(Chapter) then) =
      _$ChapterCopyWithImpl<$Res, Chapter>;
  @useResult
  $Res call(
      {bool? prefix_bismillah,
      int? revelation_order,
      String? revelation_place,
      String? arabic_name,
      String? complex_name,
      List<int>? pages,
      String? translated_name,
      int? verses,
      int? id,
      String? name});
}

/// @nodoc
class _$ChapterCopyWithImpl<$Res, $Val extends Chapter>
    implements $ChapterCopyWith<$Res> {
  _$ChapterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prefix_bismillah = freezed,
    Object? revelation_order = freezed,
    Object? revelation_place = freezed,
    Object? arabic_name = freezed,
    Object? complex_name = freezed,
    Object? pages = freezed,
    Object? translated_name = freezed,
    Object? verses = freezed,
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      prefix_bismillah: freezed == prefix_bismillah
          ? _value.prefix_bismillah
          : prefix_bismillah // ignore: cast_nullable_to_non_nullable
              as bool?,
      revelation_order: freezed == revelation_order
          ? _value.revelation_order
          : revelation_order // ignore: cast_nullable_to_non_nullable
              as int?,
      revelation_place: freezed == revelation_place
          ? _value.revelation_place
          : revelation_place // ignore: cast_nullable_to_non_nullable
              as String?,
      arabic_name: freezed == arabic_name
          ? _value.arabic_name
          : arabic_name // ignore: cast_nullable_to_non_nullable
              as String?,
      complex_name: freezed == complex_name
          ? _value.complex_name
          : complex_name // ignore: cast_nullable_to_non_nullable
              as String?,
      pages: freezed == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      translated_name: freezed == translated_name
          ? _value.translated_name
          : translated_name // ignore: cast_nullable_to_non_nullable
              as String?,
      verses: freezed == verses
          ? _value.verses
          : verses // ignore: cast_nullable_to_non_nullable
              as int?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ChapterCopyWith<$Res> implements $ChapterCopyWith<$Res> {
  factory _$$_ChapterCopyWith(
          _$_Chapter value, $Res Function(_$_Chapter) then) =
      __$$_ChapterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool? prefix_bismillah,
      int? revelation_order,
      String? revelation_place,
      String? arabic_name,
      String? complex_name,
      List<int>? pages,
      String? translated_name,
      int? verses,
      int? id,
      String? name});
}

/// @nodoc
class __$$_ChapterCopyWithImpl<$Res>
    extends _$ChapterCopyWithImpl<$Res, _$_Chapter>
    implements _$$_ChapterCopyWith<$Res> {
  __$$_ChapterCopyWithImpl(_$_Chapter _value, $Res Function(_$_Chapter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prefix_bismillah = freezed,
    Object? revelation_order = freezed,
    Object? revelation_place = freezed,
    Object? arabic_name = freezed,
    Object? complex_name = freezed,
    Object? pages = freezed,
    Object? translated_name = freezed,
    Object? verses = freezed,
    Object? id = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_Chapter(
      prefix_bismillah: freezed == prefix_bismillah
          ? _value.prefix_bismillah
          : prefix_bismillah // ignore: cast_nullable_to_non_nullable
              as bool?,
      revelation_order: freezed == revelation_order
          ? _value.revelation_order
          : revelation_order // ignore: cast_nullable_to_non_nullable
              as int?,
      revelation_place: freezed == revelation_place
          ? _value.revelation_place
          : revelation_place // ignore: cast_nullable_to_non_nullable
              as String?,
      arabic_name: freezed == arabic_name
          ? _value.arabic_name
          : arabic_name // ignore: cast_nullable_to_non_nullable
              as String?,
      complex_name: freezed == complex_name
          ? _value.complex_name
          : complex_name // ignore: cast_nullable_to_non_nullable
              as String?,
      pages: freezed == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      translated_name: freezed == translated_name
          ? _value.translated_name
          : translated_name // ignore: cast_nullable_to_non_nullable
              as String?,
      verses: freezed == verses
          ? _value.verses
          : verses // ignore: cast_nullable_to_non_nullable
              as int?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Chapter implements _Chapter {
  const _$_Chapter(
      {this.prefix_bismillah,
      this.revelation_order,
      this.revelation_place,
      this.arabic_name,
      this.complex_name,
      final List<int>? pages,
      this.translated_name,
      this.verses,
      this.id,
      this.name})
      : _pages = pages;

  factory _$_Chapter.fromJson(Map<String, dynamic> json) =>
      _$$_ChapterFromJson(json);

  /// Should the chapter start with bismillah
  @override
  final bool? prefix_bismillah;

  /// The order in which it was revealed
  @override
  final int? revelation_order;

  /// The place of revelation
  @override
  final String? revelation_place;

  /// The arabic name of the chapter
  @override
  final String? arabic_name;

  /// The complex name of the chapter
  @override
  final String? complex_name;

  /// The pages from and to e.g 1, 1
  final List<int>? _pages;

  /// The pages from and to e.g 1, 1
  @override
  List<int>? get pages {
    final value = _pages;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The translated name
  @override
  final String? translated_name;

  /// The number of verses in the chapter
  @override
  final int? verses;

  /// The id of the chapter as a number e.g 1
  @override
  final int? id;

  /// The simple name of the chapter
  @override
  final String? name;

  @override
  String toString() {
    return 'Chapter(prefix_bismillah: $prefix_bismillah, revelation_order: $revelation_order, revelation_place: $revelation_place, arabic_name: $arabic_name, complex_name: $complex_name, pages: $pages, translated_name: $translated_name, verses: $verses, id: $id, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Chapter &&
            (identical(other.prefix_bismillah, prefix_bismillah) ||
                other.prefix_bismillah == prefix_bismillah) &&
            (identical(other.revelation_order, revelation_order) ||
                other.revelation_order == revelation_order) &&
            (identical(other.revelation_place, revelation_place) ||
                other.revelation_place == revelation_place) &&
            (identical(other.arabic_name, arabic_name) ||
                other.arabic_name == arabic_name) &&
            (identical(other.complex_name, complex_name) ||
                other.complex_name == complex_name) &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            (identical(other.translated_name, translated_name) ||
                other.translated_name == translated_name) &&
            (identical(other.verses, verses) || other.verses == verses) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      prefix_bismillah,
      revelation_order,
      revelation_place,
      arabic_name,
      complex_name,
      const DeepCollectionEquality().hash(_pages),
      translated_name,
      verses,
      id,
      name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ChapterCopyWith<_$_Chapter> get copyWith =>
      __$$_ChapterCopyWithImpl<_$_Chapter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChapterToJson(
      this,
    );
  }
}

abstract class _Chapter implements Chapter {
  const factory _Chapter(
      {final bool? prefix_bismillah,
      final int? revelation_order,
      final String? revelation_place,
      final String? arabic_name,
      final String? complex_name,
      final List<int>? pages,
      final String? translated_name,
      final int? verses,
      final int? id,
      final String? name}) = _$_Chapter;

  factory _Chapter.fromJson(Map<String, dynamic> json) = _$_Chapter.fromJson;

  @override

  /// Should the chapter start with bismillah
  bool? get prefix_bismillah;
  @override

  /// The order in which it was revealed
  int? get revelation_order;
  @override

  /// The place of revelation
  String? get revelation_place;
  @override

  /// The arabic name of the chapter
  String? get arabic_name;
  @override

  /// The complex name of the chapter
  String? get complex_name;
  @override

  /// The pages from and to e.g 1, 1
  List<int>? get pages;
  @override

  /// The translated name
  String? get translated_name;
  @override

  /// The number of verses in the chapter
  int? get verses;
  @override

  /// The id of the chapter as a number e.g 1
  int? get id;
  @override

  /// The simple name of the chapter
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$_ChapterCopyWith<_$_Chapter> get copyWith =>
      throw _privateConstructorUsedError;
}

ChaptersRequest _$ChaptersRequestFromJson(Map<String, dynamic> json) {
  return _ChaptersRequest.fromJson(json);
}

/// @nodoc
mixin _$ChaptersRequest {
  /// Specify the language e.g en
  String? get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChaptersRequestCopyWith<ChaptersRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChaptersRequestCopyWith<$Res> {
  factory $ChaptersRequestCopyWith(
          ChaptersRequest value, $Res Function(ChaptersRequest) then) =
      _$ChaptersRequestCopyWithImpl<$Res, ChaptersRequest>;
  @useResult
  $Res call({String? language});
}

/// @nodoc
class _$ChaptersRequestCopyWithImpl<$Res, $Val extends ChaptersRequest>
    implements $ChaptersRequestCopyWith<$Res> {
  _$ChaptersRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ChaptersRequestCopyWith<$Res>
    implements $ChaptersRequestCopyWith<$Res> {
  factory _$$_ChaptersRequestCopyWith(
          _$_ChaptersRequest value, $Res Function(_$_ChaptersRequest) then) =
      __$$_ChaptersRequestCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? language});
}

/// @nodoc
class __$$_ChaptersRequestCopyWithImpl<$Res>
    extends _$ChaptersRequestCopyWithImpl<$Res, _$_ChaptersRequest>
    implements _$$_ChaptersRequestCopyWith<$Res> {
  __$$_ChaptersRequestCopyWithImpl(
      _$_ChaptersRequest _value, $Res Function(_$_ChaptersRequest) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_$_ChaptersRequest(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ChaptersRequest implements _ChaptersRequest {
  const _$_ChaptersRequest({this.language});

  factory _$_ChaptersRequest.fromJson(Map<String, dynamic> json) =>
      _$$_ChaptersRequestFromJson(json);

  /// Specify the language e.g en
  @override
  final String? language;

  @override
  String toString() {
    return 'ChaptersRequest(language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChaptersRequest &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ChaptersRequestCopyWith<_$_ChaptersRequest> get copyWith =>
      __$$_ChaptersRequestCopyWithImpl<_$_ChaptersRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChaptersRequestToJson(
      this,
    );
  }
}

abstract class _ChaptersRequest implements ChaptersRequest {
  const factory _ChaptersRequest({final String? language}) = _$_ChaptersRequest;

  factory _ChaptersRequest.fromJson(Map<String, dynamic> json) =
      _$_ChaptersRequest.fromJson;

  @override

  /// Specify the language e.g en
  String? get language;
  @override
  @JsonKey(ignore: true)
  _$$_ChaptersRequestCopyWith<_$_ChaptersRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

ChaptersResponse _$ChaptersResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return ChaptersResponseData.fromJson(json);
    case 'Merr':
      return ChaptersResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChaptersResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChaptersResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<Chapter>? chapters)? $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(ChaptersResponseData value)? $default, {
    TResult? Function(ChaptersResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChaptersResponseCopyWith<$Res> {
  factory $ChaptersResponseCopyWith(
          ChaptersResponse value, $Res Function(ChaptersResponse) then) =
      _$ChaptersResponseCopyWithImpl<$Res, ChaptersResponse>;
}

/// @nodoc
class _$ChaptersResponseCopyWithImpl<$Res, $Val extends ChaptersResponse>
    implements $ChaptersResponseCopyWith<$Res> {
  _$ChaptersResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChaptersResponseDataCopyWith<$Res> {
  factory _$$ChaptersResponseDataCopyWith(_$ChaptersResponseData value,
          $Res Function(_$ChaptersResponseData) then) =
      __$$ChaptersResponseDataCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Chapter>? chapters});
}

/// @nodoc
class __$$ChaptersResponseDataCopyWithImpl<$Res>
    extends _$ChaptersResponseCopyWithImpl<$Res, _$ChaptersResponseData>
    implements _$$ChaptersResponseDataCopyWith<$Res> {
  __$$ChaptersResponseDataCopyWithImpl(_$ChaptersResponseData _value,
      $Res Function(_$ChaptersResponseData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapters = freezed,
  }) {
    return _then(_$ChaptersResponseData(
      chapters: freezed == chapters
          ? _value._chapters
          : chapters // ignore: cast_nullable_to_non_nullable
              as List<Chapter>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChaptersResponseData implements ChaptersResponseData {
  const _$ChaptersResponseData(
      {final List<Chapter>? chapters, final String? $type})
      : _chapters = chapters,
        $type = $type ?? 'default';

  factory _$ChaptersResponseData.fromJson(Map<String, dynamic> json) =>
      _$$ChaptersResponseDataFromJson(json);

  final List<Chapter>? _chapters;
  @override
  List<Chapter>? get chapters {
    final value = _chapters;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChaptersResponse(chapters: $chapters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChaptersResponseData &&
            const DeepCollectionEquality().equals(other._chapters, _chapters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_chapters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChaptersResponseDataCopyWith<_$ChaptersResponseData> get copyWith =>
      __$$ChaptersResponseDataCopyWithImpl<_$ChaptersResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(chapters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<Chapter>? chapters)? $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(chapters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(chapters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(ChaptersResponseData value)? $default, {
    TResult? Function(ChaptersResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChaptersResponseDataToJson(
      this,
    );
  }
}

abstract class ChaptersResponseData implements ChaptersResponse {
  const factory ChaptersResponseData({final List<Chapter>? chapters}) =
      _$ChaptersResponseData;

  factory ChaptersResponseData.fromJson(Map<String, dynamic> json) =
      _$ChaptersResponseData.fromJson;

  List<Chapter>? get chapters;
  @JsonKey(ignore: true)
  _$$ChaptersResponseDataCopyWith<_$ChaptersResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChaptersResponseMerrCopyWith<$Res> {
  factory _$$ChaptersResponseMerrCopyWith(_$ChaptersResponseMerr value,
          $Res Function(_$ChaptersResponseMerr) then) =
      __$$ChaptersResponseMerrCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$ChaptersResponseMerrCopyWithImpl<$Res>
    extends _$ChaptersResponseCopyWithImpl<$Res, _$ChaptersResponseMerr>
    implements _$$ChaptersResponseMerrCopyWith<$Res> {
  __$$ChaptersResponseMerrCopyWithImpl(_$ChaptersResponseMerr _value,
      $Res Function(_$ChaptersResponseMerr) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$ChaptersResponseMerr(
      body: freezed == body
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChaptersResponseMerr implements ChaptersResponseMerr {
  const _$ChaptersResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$ChaptersResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$ChaptersResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChaptersResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChaptersResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChaptersResponseMerrCopyWith<_$ChaptersResponseMerr> get copyWith =>
      __$$ChaptersResponseMerrCopyWithImpl<_$ChaptersResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<Chapter>? chapters)? $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(ChaptersResponseData value)? $default, {
    TResult? Function(ChaptersResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChaptersResponseMerrToJson(
      this,
    );
  }
}

abstract class ChaptersResponseMerr implements ChaptersResponse {
  const factory ChaptersResponseMerr({final Map<String, dynamic>? body}) =
      _$ChaptersResponseMerr;

  factory ChaptersResponseMerr.fromJson(Map<String, dynamic> json) =
      _$ChaptersResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$ChaptersResponseMerrCopyWith<_$ChaptersResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Interpretation _$InterpretationFromJson(Map<String, dynamic> json) {
  return _Interpretation.fromJson(json);
}

/// @nodoc
mixin _$Interpretation {
  /// The unique id of the interpretation
  int? get id => throw _privateConstructorUsedError;

  /// The source of the interpretation
  String? get source => throw _privateConstructorUsedError;

  /// The translated text
  String? get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InterpretationCopyWith<Interpretation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InterpretationCopyWith<$Res> {
  factory $InterpretationCopyWith(
          Interpretation value, $Res Function(Interpretation) then) =
      _$InterpretationCopyWithImpl<$Res, Interpretation>;
  @useResult
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class _$InterpretationCopyWithImpl<$Res, $Val extends Interpretation>
    implements $InterpretationCopyWith<$Res> {
  _$InterpretationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_InterpretationCopyWith<$Res>
    implements $InterpretationCopyWith<$Res> {
  factory _$$_InterpretationCopyWith(
          _$_Interpretation value, $Res Function(_$_Interpretation) then) =
      __$$_InterpretationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class __$$_InterpretationCopyWithImpl<$Res>
    extends _$InterpretationCopyWithImpl<$Res, _$_Interpretation>
    implements _$$_InterpretationCopyWith<$Res> {
  __$$_InterpretationCopyWithImpl(
      _$_Interpretation _value, $Res Function(_$_Interpretation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_$_Interpretation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Interpretation implements _Interpretation {
  const _$_Interpretation({this.id, this.source, this.text});

  factory _$_Interpretation.fromJson(Map<String, dynamic> json) =>
      _$$_InterpretationFromJson(json);

  /// The unique id of the interpretation
  @override
  final int? id;

  /// The source of the interpretation
  @override
  final String? source;

  /// The translated text
  @override
  final String? text;

  @override
  String toString() {
    return 'Interpretation(id: $id, source: $source, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Interpretation &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, source, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InterpretationCopyWith<_$_Interpretation> get copyWith =>
      __$$_InterpretationCopyWithImpl<_$_Interpretation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InterpretationToJson(
      this,
    );
  }
}

abstract class _Interpretation implements Interpretation {
  const factory _Interpretation(
      {final int? id,
      final String? source,
      final String? text}) = _$_Interpretation;

  factory _Interpretation.fromJson(Map<String, dynamic> json) =
      _$_Interpretation.fromJson;

  @override

  /// The unique id of the interpretation
  int? get id;
  @override

  /// The source of the interpretation
  String? get source;
  @override

  /// The translated text
  String? get text;
  @override
  @JsonKey(ignore: true)
  _$$_InterpretationCopyWith<_$_Interpretation> get copyWith =>
      throw _privateConstructorUsedError;
}

Result _$ResultFromJson(Map<String, dynamic> json) {
  return _Result.fromJson(json);
}

/// @nodoc
mixin _$Result {
  /// The unique verse id across the Quran
  int? get verse_id => throw _privateConstructorUsedError;

  /// The verse key e.g 1:1
  String? get verse_key => throw _privateConstructorUsedError;

  /// The associated arabic text
  String? get text => throw _privateConstructorUsedError;

  /// The related translations to the text
  List<Translation>? get translations => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResultCopyWith<Result> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResultCopyWith<$Res> {
  factory $ResultCopyWith(Result value, $Res Function(Result) then) =
      _$ResultCopyWithImpl<$Res, Result>;
  @useResult
  $Res call(
      {int? verse_id,
      String? verse_key,
      String? text,
      List<Translation>? translations});
}

/// @nodoc
class _$ResultCopyWithImpl<$Res, $Val extends Result>
    implements $ResultCopyWith<$Res> {
  _$ResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? verse_id = freezed,
    Object? verse_key = freezed,
    Object? text = freezed,
    Object? translations = freezed,
  }) {
    return _then(_value.copyWith(
      verse_id: freezed == verse_id
          ? _value.verse_id
          : verse_id // ignore: cast_nullable_to_non_nullable
              as int?,
      verse_key: freezed == verse_key
          ? _value.verse_key
          : verse_key // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: freezed == translations
          ? _value.translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ResultCopyWith<$Res> implements $ResultCopyWith<$Res> {
  factory _$$_ResultCopyWith(_$_Result value, $Res Function(_$_Result) then) =
      __$$_ResultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? verse_id,
      String? verse_key,
      String? text,
      List<Translation>? translations});
}

/// @nodoc
class __$$_ResultCopyWithImpl<$Res>
    extends _$ResultCopyWithImpl<$Res, _$_Result>
    implements _$$_ResultCopyWith<$Res> {
  __$$_ResultCopyWithImpl(_$_Result _value, $Res Function(_$_Result) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? verse_id = freezed,
    Object? verse_key = freezed,
    Object? text = freezed,
    Object? translations = freezed,
  }) {
    return _then(_$_Result(
      verse_id: freezed == verse_id
          ? _value.verse_id
          : verse_id // ignore: cast_nullable_to_non_nullable
              as int?,
      verse_key: freezed == verse_key
          ? _value.verse_key
          : verse_key // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: freezed == translations
          ? _value._translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Result implements _Result {
  const _$_Result(
      {this.verse_id,
      this.verse_key,
      this.text,
      final List<Translation>? translations})
      : _translations = translations;

  factory _$_Result.fromJson(Map<String, dynamic> json) =>
      _$$_ResultFromJson(json);

  /// The unique verse id across the Quran
  @override
  final int? verse_id;

  /// The verse key e.g 1:1
  @override
  final String? verse_key;

  /// The associated arabic text
  @override
  final String? text;

  /// The related translations to the text
  final List<Translation>? _translations;

  /// The related translations to the text
  @override
  List<Translation>? get translations {
    final value = _translations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Result(verse_id: $verse_id, verse_key: $verse_key, text: $text, translations: $translations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Result &&
            (identical(other.verse_id, verse_id) ||
                other.verse_id == verse_id) &&
            (identical(other.verse_key, verse_key) ||
                other.verse_key == verse_key) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._translations, _translations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, verse_id, verse_key, text,
      const DeepCollectionEquality().hash(_translations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ResultCopyWith<_$_Result> get copyWith =>
      __$$_ResultCopyWithImpl<_$_Result>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ResultToJson(
      this,
    );
  }
}

abstract class _Result implements Result {
  const factory _Result(
      {final int? verse_id,
      final String? verse_key,
      final String? text,
      final List<Translation>? translations}) = _$_Result;

  factory _Result.fromJson(Map<String, dynamic> json) = _$_Result.fromJson;

  @override

  /// The unique verse id across the Quran
  int? get verse_id;
  @override

  /// The verse key e.g 1:1
  String? get verse_key;
  @override

  /// The associated arabic text
  String? get text;
  @override

  /// The related translations to the text
  List<Translation>? get translations;
  @override
  @JsonKey(ignore: true)
  _$$_ResultCopyWith<_$_Result> get copyWith =>
      throw _privateConstructorUsedError;
}

SearchRequest _$SearchRequestFromJson(Map<String, dynamic> json) {
  return _SearchRequest.fromJson(json);
}

/// @nodoc
mixin _$SearchRequest {
  /// The language for translation
  String? get language => throw _privateConstructorUsedError;

  /// The number of results to return
  int? get limit => throw _privateConstructorUsedError;

  /// The pagination number
  int? get page => throw _privateConstructorUsedError;

  /// The query to ask
  String? get query => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SearchRequestCopyWith<SearchRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchRequestCopyWith<$Res> {
  factory $SearchRequestCopyWith(
          SearchRequest value, $Res Function(SearchRequest) then) =
      _$SearchRequestCopyWithImpl<$Res, SearchRequest>;
  @useResult
  $Res call({String? language, int? limit, int? page, String? query});
}

/// @nodoc
class _$SearchRequestCopyWithImpl<$Res, $Val extends SearchRequest>
    implements $SearchRequestCopyWith<$Res> {
  _$SearchRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? query = freezed,
  }) {
    return _then(_value.copyWith(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: freezed == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SearchRequestCopyWith<$Res>
    implements $SearchRequestCopyWith<$Res> {
  factory _$$_SearchRequestCopyWith(
          _$_SearchRequest value, $Res Function(_$_SearchRequest) then) =
      __$$_SearchRequestCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? language, int? limit, int? page, String? query});
}

/// @nodoc
class __$$_SearchRequestCopyWithImpl<$Res>
    extends _$SearchRequestCopyWithImpl<$Res, _$_SearchRequest>
    implements _$$_SearchRequestCopyWith<$Res> {
  __$$_SearchRequestCopyWithImpl(
      _$_SearchRequest _value, $Res Function(_$_SearchRequest) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? query = freezed,
  }) {
    return _then(_$_SearchRequest(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: freezed == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SearchRequest implements _SearchRequest {
  const _$_SearchRequest({this.language, this.limit, this.page, this.query});

  factory _$_SearchRequest.fromJson(Map<String, dynamic> json) =>
      _$$_SearchRequestFromJson(json);

  /// The language for translation
  @override
  final String? language;

  /// The number of results to return
  @override
  final int? limit;

  /// The pagination number
  @override
  final int? page;

  /// The query to ask
  @override
  final String? query;

  @override
  String toString() {
    return 'SearchRequest(language: $language, limit: $limit, page: $page, query: $query)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SearchRequest &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.query, query) || other.query == query));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, language, limit, page, query);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SearchRequestCopyWith<_$_SearchRequest> get copyWith =>
      __$$_SearchRequestCopyWithImpl<_$_SearchRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SearchRequestToJson(
      this,
    );
  }
}

abstract class _SearchRequest implements SearchRequest {
  const factory _SearchRequest(
      {final String? language,
      final int? limit,
      final int? page,
      final String? query}) = _$_SearchRequest;

  factory _SearchRequest.fromJson(Map<String, dynamic> json) =
      _$_SearchRequest.fromJson;

  @override

  /// The language for translation
  String? get language;
  @override

  /// The number of results to return
  int? get limit;
  @override

  /// The pagination number
  int? get page;
  @override

  /// The query to ask
  String? get query;
  @override
  @JsonKey(ignore: true)
  _$$_SearchRequestCopyWith<_$_SearchRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

SearchResponse _$SearchResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return SearchResponseData.fromJson(json);
    case 'Merr':
      return SearchResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SearchResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SearchResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SearchResponseData value)? $default, {
    TResult? Function(SearchResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchResponseCopyWith<$Res> {
  factory $SearchResponseCopyWith(
          SearchResponse value, $Res Function(SearchResponse) then) =
      _$SearchResponseCopyWithImpl<$Res, SearchResponse>;
}

/// @nodoc
class _$SearchResponseCopyWithImpl<$Res, $Val extends SearchResponse>
    implements $SearchResponseCopyWith<$Res> {
  _$SearchResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SearchResponseDataCopyWith<$Res> {
  factory _$$SearchResponseDataCopyWith(_$SearchResponseData value,
          $Res Function(_$SearchResponseData) then) =
      __$$SearchResponseDataCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {int? page,
      String? query,
      List<Result>? results,
      int? total_pages,
      int? total_results});
}

/// @nodoc
class __$$SearchResponseDataCopyWithImpl<$Res>
    extends _$SearchResponseCopyWithImpl<$Res, _$SearchResponseData>
    implements _$$SearchResponseDataCopyWith<$Res> {
  __$$SearchResponseDataCopyWithImpl(
      _$SearchResponseData _value, $Res Function(_$SearchResponseData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? page = freezed,
    Object? query = freezed,
    Object? results = freezed,
    Object? total_pages = freezed,
    Object? total_results = freezed,
  }) {
    return _then(_$SearchResponseData(
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: freezed == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
      results: freezed == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Result>?,
      total_pages: freezed == total_pages
          ? _value.total_pages
          : total_pages // ignore: cast_nullable_to_non_nullable
              as int?,
      total_results: freezed == total_results
          ? _value.total_results
          : total_results // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SearchResponseData implements SearchResponseData {
  const _$SearchResponseData(
      {this.page,
      this.query,
      final List<Result>? results,
      this.total_pages,
      this.total_results,
      final String? $type})
      : _results = results,
        $type = $type ?? 'default';

  factory _$SearchResponseData.fromJson(Map<String, dynamic> json) =>
      _$$SearchResponseDataFromJson(json);

  /// The current page
  @override
  final int? page;

  /// The question asked
  @override
  final String? query;

  /// The results for the query
  final List<Result>? _results;

  /// The results for the query
  @override
  List<Result>? get results {
    final value = _results;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The total pages
  @override
  final int? total_pages;

  /// The total results returned
  @override
  final int? total_results;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SearchResponse(page: $page, query: $query, results: $results, total_pages: $total_pages, total_results: $total_results)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchResponseData &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.query, query) || other.query == query) &&
            const DeepCollectionEquality().equals(other._results, _results) &&
            (identical(other.total_pages, total_pages) ||
                other.total_pages == total_pages) &&
            (identical(other.total_results, total_results) ||
                other.total_results == total_results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      page,
      query,
      const DeepCollectionEquality().hash(_results),
      total_pages,
      total_results);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchResponseDataCopyWith<_$SearchResponseData> get copyWith =>
      __$$SearchResponseDataCopyWithImpl<_$SearchResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(page, query, results, total_pages, total_results);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(page, query, results, total_pages, total_results);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(page, query, results, total_pages, total_results);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SearchResponseData value)? $default, {
    TResult? Function(SearchResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SearchResponseDataToJson(
      this,
    );
  }
}

abstract class SearchResponseData implements SearchResponse {
  const factory SearchResponseData(
      {final int? page,
      final String? query,
      final List<Result>? results,
      final int? total_pages,
      final int? total_results}) = _$SearchResponseData;

  factory SearchResponseData.fromJson(Map<String, dynamic> json) =
      _$SearchResponseData.fromJson;

  /// The current page
  int? get page;

  /// The question asked
  String? get query;

  /// The results for the query
  List<Result>? get results;

  /// The total pages
  int? get total_pages;

  /// The total results returned
  int? get total_results;
  @JsonKey(ignore: true)
  _$$SearchResponseDataCopyWith<_$SearchResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchResponseMerrCopyWith<$Res> {
  factory _$$SearchResponseMerrCopyWith(_$SearchResponseMerr value,
          $Res Function(_$SearchResponseMerr) then) =
      __$$SearchResponseMerrCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$SearchResponseMerrCopyWithImpl<$Res>
    extends _$SearchResponseCopyWithImpl<$Res, _$SearchResponseMerr>
    implements _$$SearchResponseMerrCopyWith<$Res> {
  __$$SearchResponseMerrCopyWithImpl(
      _$SearchResponseMerr _value, $Res Function(_$SearchResponseMerr) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$SearchResponseMerr(
      body: freezed == body
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SearchResponseMerr implements SearchResponseMerr {
  const _$SearchResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$SearchResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$SearchResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SearchResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchResponseMerrCopyWith<_$SearchResponseMerr> get copyWith =>
      __$$SearchResponseMerrCopyWithImpl<_$SearchResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SearchResponseData value)? $default, {
    TResult? Function(SearchResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SearchResponseMerrToJson(
      this,
    );
  }
}

abstract class SearchResponseMerr implements SearchResponse {
  const factory SearchResponseMerr({final Map<String, dynamic>? body}) =
      _$SearchResponseMerr;

  factory SearchResponseMerr.fromJson(Map<String, dynamic> json) =
      _$SearchResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$SearchResponseMerrCopyWith<_$SearchResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

SummaryRequest _$SummaryRequestFromJson(Map<String, dynamic> json) {
  return _SummaryRequest.fromJson(json);
}

/// @nodoc
mixin _$SummaryRequest {
  /// The chapter id e.g 1
  int? get chapter => throw _privateConstructorUsedError;

  /// Specify the language e.g en
  String? get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SummaryRequestCopyWith<SummaryRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SummaryRequestCopyWith<$Res> {
  factory $SummaryRequestCopyWith(
          SummaryRequest value, $Res Function(SummaryRequest) then) =
      _$SummaryRequestCopyWithImpl<$Res, SummaryRequest>;
  @useResult
  $Res call({int? chapter, String? language});
}

/// @nodoc
class _$SummaryRequestCopyWithImpl<$Res, $Val extends SummaryRequest>
    implements $SummaryRequestCopyWith<$Res> {
  _$SummaryRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapter = freezed,
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SummaryRequestCopyWith<$Res>
    implements $SummaryRequestCopyWith<$Res> {
  factory _$$_SummaryRequestCopyWith(
          _$_SummaryRequest value, $Res Function(_$_SummaryRequest) then) =
      __$$_SummaryRequestCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? chapter, String? language});
}

/// @nodoc
class __$$_SummaryRequestCopyWithImpl<$Res>
    extends _$SummaryRequestCopyWithImpl<$Res, _$_SummaryRequest>
    implements _$$_SummaryRequestCopyWith<$Res> {
  __$$_SummaryRequestCopyWithImpl(
      _$_SummaryRequest _value, $Res Function(_$_SummaryRequest) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapter = freezed,
    Object? language = freezed,
  }) {
    return _then(_$_SummaryRequest(
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SummaryRequest implements _SummaryRequest {
  const _$_SummaryRequest({this.chapter, this.language});

  factory _$_SummaryRequest.fromJson(Map<String, dynamic> json) =>
      _$$_SummaryRequestFromJson(json);

  /// The chapter id e.g 1
  @override
  final int? chapter;

  /// Specify the language e.g en
  @override
  final String? language;

  @override
  String toString() {
    return 'SummaryRequest(chapter: $chapter, language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SummaryRequest &&
            (identical(other.chapter, chapter) || other.chapter == chapter) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, chapter, language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SummaryRequestCopyWith<_$_SummaryRequest> get copyWith =>
      __$$_SummaryRequestCopyWithImpl<_$_SummaryRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SummaryRequestToJson(
      this,
    );
  }
}

abstract class _SummaryRequest implements SummaryRequest {
  const factory _SummaryRequest({final int? chapter, final String? language}) =
      _$_SummaryRequest;

  factory _SummaryRequest.fromJson(Map<String, dynamic> json) =
      _$_SummaryRequest.fromJson;

  @override

  /// The chapter id e.g 1
  int? get chapter;
  @override

  /// Specify the language e.g en
  String? get language;
  @override
  @JsonKey(ignore: true)
  _$$_SummaryRequestCopyWith<_$_SummaryRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

SummaryResponse _$SummaryResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return SummaryResponseData.fromJson(json);
    case 'Merr':
      return SummaryResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SummaryResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SummaryResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SummaryResponseData value)? $default, {
    TResult? Function(SummaryResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SummaryResponseCopyWith<$Res> {
  factory $SummaryResponseCopyWith(
          SummaryResponse value, $Res Function(SummaryResponse) then) =
      _$SummaryResponseCopyWithImpl<$Res, SummaryResponse>;
}

/// @nodoc
class _$SummaryResponseCopyWithImpl<$Res, $Val extends SummaryResponse>
    implements $SummaryResponseCopyWith<$Res> {
  _$SummaryResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SummaryResponseDataCopyWith<$Res> {
  factory _$$SummaryResponseDataCopyWith(_$SummaryResponseData value,
          $Res Function(_$SummaryResponseData) then) =
      __$$SummaryResponseDataCopyWithImpl<$Res>;
  @useResult
  $Res call({String? summary, String? text, int? chapter, String? source});
}

/// @nodoc
class __$$SummaryResponseDataCopyWithImpl<$Res>
    extends _$SummaryResponseCopyWithImpl<$Res, _$SummaryResponseData>
    implements _$$SummaryResponseDataCopyWith<$Res> {
  __$$SummaryResponseDataCopyWithImpl(
      _$SummaryResponseData _value, $Res Function(_$SummaryResponseData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? text = freezed,
    Object? chapter = freezed,
    Object? source = freezed,
  }) {
    return _then(_$SummaryResponseData(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SummaryResponseData implements SummaryResponseData {
  const _$SummaryResponseData(
      {this.summary, this.text, this.chapter, this.source, final String? $type})
      : $type = $type ?? 'default';

  factory _$SummaryResponseData.fromJson(Map<String, dynamic> json) =>
      _$$SummaryResponseDataFromJson(json);

  /// The short summary for the chapter
  @override
  final String? summary;

  /// The full description for the chapter
  @override
  final String? text;

  /// The chapter id
  @override
  final int? chapter;

  /// The source of the summary
  @override
  final String? source;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SummaryResponse(summary: $summary, text: $text, chapter: $chapter, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SummaryResponseData &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.chapter, chapter) || other.chapter == chapter) &&
            (identical(other.source, source) || other.source == source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, summary, text, chapter, source);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SummaryResponseDataCopyWith<_$SummaryResponseData> get copyWith =>
      __$$SummaryResponseDataCopyWithImpl<_$SummaryResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(summary, text, chapter, source);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(summary, text, chapter, source);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(summary, text, chapter, source);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SummaryResponseData value)? $default, {
    TResult? Function(SummaryResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SummaryResponseDataToJson(
      this,
    );
  }
}

abstract class SummaryResponseData implements SummaryResponse {
  const factory SummaryResponseData(
      {final String? summary,
      final String? text,
      final int? chapter,
      final String? source}) = _$SummaryResponseData;

  factory SummaryResponseData.fromJson(Map<String, dynamic> json) =
      _$SummaryResponseData.fromJson;

  /// The short summary for the chapter
  String? get summary;

  /// The full description for the chapter
  String? get text;

  /// The chapter id
  int? get chapter;

  /// The source of the summary
  String? get source;
  @JsonKey(ignore: true)
  _$$SummaryResponseDataCopyWith<_$SummaryResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SummaryResponseMerrCopyWith<$Res> {
  factory _$$SummaryResponseMerrCopyWith(_$SummaryResponseMerr value,
          $Res Function(_$SummaryResponseMerr) then) =
      __$$SummaryResponseMerrCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$SummaryResponseMerrCopyWithImpl<$Res>
    extends _$SummaryResponseCopyWithImpl<$Res, _$SummaryResponseMerr>
    implements _$$SummaryResponseMerrCopyWith<$Res> {
  __$$SummaryResponseMerrCopyWithImpl(
      _$SummaryResponseMerr _value, $Res Function(_$SummaryResponseMerr) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$SummaryResponseMerr(
      body: freezed == body
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SummaryResponseMerr implements SummaryResponseMerr {
  const _$SummaryResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$SummaryResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$SummaryResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SummaryResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SummaryResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SummaryResponseMerrCopyWith<_$SummaryResponseMerr> get copyWith =>
      __$$SummaryResponseMerrCopyWithImpl<_$SummaryResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String? summary, String? text, int? chapter, String? source)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(SummaryResponseData value)? $default, {
    TResult? Function(SummaryResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SummaryResponseMerrToJson(
      this,
    );
  }
}

abstract class SummaryResponseMerr implements SummaryResponse {
  const factory SummaryResponseMerr({final Map<String, dynamic>? body}) =
      _$SummaryResponseMerr;

  factory SummaryResponseMerr.fromJson(Map<String, dynamic> json) =
      _$SummaryResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$SummaryResponseMerrCopyWith<_$SummaryResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Translation _$TranslationFromJson(Map<String, dynamic> json) {
  return _Translation.fromJson(json);
}

/// @nodoc
mixin _$Translation {
  /// The unique id of the translation
  int? get id => throw _privateConstructorUsedError;

  /// The source of the translation
  String? get source => throw _privateConstructorUsedError;

  /// The translated text
  String? get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TranslationCopyWith<Translation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TranslationCopyWith<$Res> {
  factory $TranslationCopyWith(
          Translation value, $Res Function(Translation) then) =
      _$TranslationCopyWithImpl<$Res, Translation>;
  @useResult
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class _$TranslationCopyWithImpl<$Res, $Val extends Translation>
    implements $TranslationCopyWith<$Res> {
  _$TranslationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TranslationCopyWith<$Res>
    implements $TranslationCopyWith<$Res> {
  factory _$$_TranslationCopyWith(
          _$_Translation value, $Res Function(_$_Translation) then) =
      __$$_TranslationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class __$$_TranslationCopyWithImpl<$Res>
    extends _$TranslationCopyWithImpl<$Res, _$_Translation>
    implements _$$_TranslationCopyWith<$Res> {
  __$$_TranslationCopyWithImpl(
      _$_Translation _value, $Res Function(_$_Translation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_$_Translation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Translation implements _Translation {
  const _$_Translation({this.id, this.source, this.text});

  factory _$_Translation.fromJson(Map<String, dynamic> json) =>
      _$$_TranslationFromJson(json);

  /// The unique id of the translation
  @override
  final int? id;

  /// The source of the translation
  @override
  final String? source;

  /// The translated text
  @override
  final String? text;

  @override
  String toString() {
    return 'Translation(id: $id, source: $source, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Translation &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, source, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TranslationCopyWith<_$_Translation> get copyWith =>
      __$$_TranslationCopyWithImpl<_$_Translation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TranslationToJson(
      this,
    );
  }
}

abstract class _Translation implements Translation {
  const factory _Translation(
      {final int? id,
      final String? source,
      final String? text}) = _$_Translation;

  factory _Translation.fromJson(Map<String, dynamic> json) =
      _$_Translation.fromJson;

  @override

  /// The unique id of the translation
  int? get id;
  @override

  /// The source of the translation
  String? get source;
  @override

  /// The translated text
  String? get text;
  @override
  @JsonKey(ignore: true)
  _$$_TranslationCopyWith<_$_Translation> get copyWith =>
      throw _privateConstructorUsedError;
}

Verse _$VerseFromJson(Map<String, dynamic> json) {
  return _Verse.fromJson(json);
}

/// @nodoc
mixin _$Verse {
  /// The interpretations of the verse
  List<Interpretation>? get interpretations =>
      throw _privateConstructorUsedError;

  /// The key of this verse (chapter:verse) e.g 1:1
  String? get key => throw _privateConstructorUsedError;

  /// The verse number in this chapter
  int? get number => throw _privateConstructorUsedError;

  /// The basic translation of the verse
  String? get translated_text => throw _privateConstructorUsedError;

  /// The phonetic transliteration from arabic
  String? get transliteration => throw _privateConstructorUsedError;

  /// The unique id of the verse in the whole book
  int? get id => throw _privateConstructorUsedError;

  /// The page of the Quran this verse is on
  int? get page => throw _privateConstructorUsedError;

  /// The arabic text for this verse
  String? get text => throw _privateConstructorUsedError;

  /// The alternative translations for the verse
  List<Translation>? get translations => throw _privateConstructorUsedError;

  /// The individual words within the verse (Ayah)
  List<Word>? get words => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VerseCopyWith<Verse> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VerseCopyWith<$Res> {
  factory $VerseCopyWith(Verse value, $Res Function(Verse) then) =
      _$VerseCopyWithImpl<$Res, Verse>;
  @useResult
  $Res call(
      {List<Interpretation>? interpretations,
      String? key,
      int? number,
      String? translated_text,
      String? transliteration,
      int? id,
      int? page,
      String? text,
      List<Translation>? translations,
      List<Word>? words});
}

/// @nodoc
class _$VerseCopyWithImpl<$Res, $Val extends Verse>
    implements $VerseCopyWith<$Res> {
  _$VerseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? interpretations = freezed,
    Object? key = freezed,
    Object? number = freezed,
    Object? translated_text = freezed,
    Object? transliteration = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? text = freezed,
    Object? translations = freezed,
    Object? words = freezed,
  }) {
    return _then(_value.copyWith(
      interpretations: freezed == interpretations
          ? _value.interpretations
          : interpretations // ignore: cast_nullable_to_non_nullable
              as List<Interpretation>?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      translated_text: freezed == translated_text
          ? _value.translated_text
          : translated_text // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: freezed == transliteration
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: freezed == translations
          ? _value.translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      words: freezed == words
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as List<Word>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_VerseCopyWith<$Res> implements $VerseCopyWith<$Res> {
  factory _$$_VerseCopyWith(_$_Verse value, $Res Function(_$_Verse) then) =
      __$$_VerseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Interpretation>? interpretations,
      String? key,
      int? number,
      String? translated_text,
      String? transliteration,
      int? id,
      int? page,
      String? text,
      List<Translation>? translations,
      List<Word>? words});
}

/// @nodoc
class __$$_VerseCopyWithImpl<$Res> extends _$VerseCopyWithImpl<$Res, _$_Verse>
    implements _$$_VerseCopyWith<$Res> {
  __$$_VerseCopyWithImpl(_$_Verse _value, $Res Function(_$_Verse) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? interpretations = freezed,
    Object? key = freezed,
    Object? number = freezed,
    Object? translated_text = freezed,
    Object? transliteration = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? text = freezed,
    Object? translations = freezed,
    Object? words = freezed,
  }) {
    return _then(_$_Verse(
      interpretations: freezed == interpretations
          ? _value._interpretations
          : interpretations // ignore: cast_nullable_to_non_nullable
              as List<Interpretation>?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      translated_text: freezed == translated_text
          ? _value.translated_text
          : translated_text // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: freezed == transliteration
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: freezed == translations
          ? _value._translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      words: freezed == words
          ? _value._words
          : words // ignore: cast_nullable_to_non_nullable
              as List<Word>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Verse implements _Verse {
  const _$_Verse(
      {final List<Interpretation>? interpretations,
      this.key,
      this.number,
      this.translated_text,
      this.transliteration,
      this.id,
      this.page,
      this.text,
      final List<Translation>? translations,
      final List<Word>? words})
      : _interpretations = interpretations,
        _translations = translations,
        _words = words;

  factory _$_Verse.fromJson(Map<String, dynamic> json) =>
      _$$_VerseFromJson(json);

  /// The interpretations of the verse
  final List<Interpretation>? _interpretations;

  /// The interpretations of the verse
  @override
  List<Interpretation>? get interpretations {
    final value = _interpretations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The key of this verse (chapter:verse) e.g 1:1
  @override
  final String? key;

  /// The verse number in this chapter
  @override
  final int? number;

  /// The basic translation of the verse
  @override
  final String? translated_text;

  /// The phonetic transliteration from arabic
  @override
  final String? transliteration;

  /// The unique id of the verse in the whole book
  @override
  final int? id;

  /// The page of the Quran this verse is on
  @override
  final int? page;

  /// The arabic text for this verse
  @override
  final String? text;

  /// The alternative translations for the verse
  final List<Translation>? _translations;

  /// The alternative translations for the verse
  @override
  List<Translation>? get translations {
    final value = _translations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The individual words within the verse (Ayah)
  final List<Word>? _words;

  /// The individual words within the verse (Ayah)
  @override
  List<Word>? get words {
    final value = _words;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Verse(interpretations: $interpretations, key: $key, number: $number, translated_text: $translated_text, transliteration: $transliteration, id: $id, page: $page, text: $text, translations: $translations, words: $words)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Verse &&
            const DeepCollectionEquality()
                .equals(other._interpretations, _interpretations) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.translated_text, translated_text) ||
                other.translated_text == translated_text) &&
            (identical(other.transliteration, transliteration) ||
                other.transliteration == transliteration) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._translations, _translations) &&
            const DeepCollectionEquality().equals(other._words, _words));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_interpretations),
      key,
      number,
      translated_text,
      transliteration,
      id,
      page,
      text,
      const DeepCollectionEquality().hash(_translations),
      const DeepCollectionEquality().hash(_words));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_VerseCopyWith<_$_Verse> get copyWith =>
      __$$_VerseCopyWithImpl<_$_Verse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_VerseToJson(
      this,
    );
  }
}

abstract class _Verse implements Verse {
  const factory _Verse(
      {final List<Interpretation>? interpretations,
      final String? key,
      final int? number,
      final String? translated_text,
      final String? transliteration,
      final int? id,
      final int? page,
      final String? text,
      final List<Translation>? translations,
      final List<Word>? words}) = _$_Verse;

  factory _Verse.fromJson(Map<String, dynamic> json) = _$_Verse.fromJson;

  @override

  /// The interpretations of the verse
  List<Interpretation>? get interpretations;
  @override

  /// The key of this verse (chapter:verse) e.g 1:1
  String? get key;
  @override

  /// The verse number in this chapter
  int? get number;
  @override

  /// The basic translation of the verse
  String? get translated_text;
  @override

  /// The phonetic transliteration from arabic
  String? get transliteration;
  @override

  /// The unique id of the verse in the whole book
  int? get id;
  @override

  /// The page of the Quran this verse is on
  int? get page;
  @override

  /// The arabic text for this verse
  String? get text;
  @override

  /// The alternative translations for the verse
  List<Translation>? get translations;
  @override

  /// The individual words within the verse (Ayah)
  List<Word>? get words;
  @override
  @JsonKey(ignore: true)
  _$$_VerseCopyWith<_$_Verse> get copyWith =>
      throw _privateConstructorUsedError;
}

VersesRequest _$VersesRequestFromJson(Map<String, dynamic> json) {
  return _VersesRequest.fromJson(json);
}

/// @nodoc
mixin _$VersesRequest {
  /// The chapter id to retrieve
  int? get chapter => throw _privateConstructorUsedError;

  /// Return the interpretation (tafsir)
  bool? get interpret => throw _privateConstructorUsedError;

  /// The language of translation
  String? get language => throw _privateConstructorUsedError;

  /// The verses per page
  int? get limit => throw _privateConstructorUsedError;

  /// The page number to request
  int? get page => throw _privateConstructorUsedError;

  /// Return alternate translations
  bool? get translate => throw _privateConstructorUsedError;

  /// Return the individual words with the verses
  bool? get words => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VersesRequestCopyWith<VersesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersesRequestCopyWith<$Res> {
  factory $VersesRequestCopyWith(
          VersesRequest value, $Res Function(VersesRequest) then) =
      _$VersesRequestCopyWithImpl<$Res, VersesRequest>;
  @useResult
  $Res call(
      {int? chapter,
      bool? interpret,
      String? language,
      int? limit,
      int? page,
      bool? translate,
      bool? words});
}

/// @nodoc
class _$VersesRequestCopyWithImpl<$Res, $Val extends VersesRequest>
    implements $VersesRequestCopyWith<$Res> {
  _$VersesRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapter = freezed,
    Object? interpret = freezed,
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? translate = freezed,
    Object? words = freezed,
  }) {
    return _then(_value.copyWith(
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      interpret: freezed == interpret
          ? _value.interpret
          : interpret // ignore: cast_nullable_to_non_nullable
              as bool?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      translate: freezed == translate
          ? _value.translate
          : translate // ignore: cast_nullable_to_non_nullable
              as bool?,
      words: freezed == words
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_VersesRequestCopyWith<$Res>
    implements $VersesRequestCopyWith<$Res> {
  factory _$$_VersesRequestCopyWith(
          _$_VersesRequest value, $Res Function(_$_VersesRequest) then) =
      __$$_VersesRequestCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? chapter,
      bool? interpret,
      String? language,
      int? limit,
      int? page,
      bool? translate,
      bool? words});
}

/// @nodoc
class __$$_VersesRequestCopyWithImpl<$Res>
    extends _$VersesRequestCopyWithImpl<$Res, _$_VersesRequest>
    implements _$$_VersesRequestCopyWith<$Res> {
  __$$_VersesRequestCopyWithImpl(
      _$_VersesRequest _value, $Res Function(_$_VersesRequest) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapter = freezed,
    Object? interpret = freezed,
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? translate = freezed,
    Object? words = freezed,
  }) {
    return _then(_$_VersesRequest(
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      interpret: freezed == interpret
          ? _value.interpret
          : interpret // ignore: cast_nullable_to_non_nullable
              as bool?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      translate: freezed == translate
          ? _value.translate
          : translate // ignore: cast_nullable_to_non_nullable
              as bool?,
      words: freezed == words
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_VersesRequest implements _VersesRequest {
  const _$_VersesRequest(
      {this.chapter,
      this.interpret,
      this.language,
      this.limit,
      this.page,
      this.translate,
      this.words});

  factory _$_VersesRequest.fromJson(Map<String, dynamic> json) =>
      _$$_VersesRequestFromJson(json);

  /// The chapter id to retrieve
  @override
  final int? chapter;

  /// Return the interpretation (tafsir)
  @override
  final bool? interpret;

  /// The language of translation
  @override
  final String? language;

  /// The verses per page
  @override
  final int? limit;

  /// The page number to request
  @override
  final int? page;

  /// Return alternate translations
  @override
  final bool? translate;

  /// Return the individual words with the verses
  @override
  final bool? words;

  @override
  String toString() {
    return 'VersesRequest(chapter: $chapter, interpret: $interpret, language: $language, limit: $limit, page: $page, translate: $translate, words: $words)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VersesRequest &&
            (identical(other.chapter, chapter) || other.chapter == chapter) &&
            (identical(other.interpret, interpret) ||
                other.interpret == interpret) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.translate, translate) ||
                other.translate == translate) &&
            (identical(other.words, words) || other.words == words));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, chapter, interpret, language, limit, page, translate, words);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_VersesRequestCopyWith<_$_VersesRequest> get copyWith =>
      __$$_VersesRequestCopyWithImpl<_$_VersesRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_VersesRequestToJson(
      this,
    );
  }
}

abstract class _VersesRequest implements VersesRequest {
  const factory _VersesRequest(
      {final int? chapter,
      final bool? interpret,
      final String? language,
      final int? limit,
      final int? page,
      final bool? translate,
      final bool? words}) = _$_VersesRequest;

  factory _VersesRequest.fromJson(Map<String, dynamic> json) =
      _$_VersesRequest.fromJson;

  @override

  /// The chapter id to retrieve
  int? get chapter;
  @override

  /// Return the interpretation (tafsir)
  bool? get interpret;
  @override

  /// The language of translation
  String? get language;
  @override

  /// The verses per page
  int? get limit;
  @override

  /// The page number to request
  int? get page;
  @override

  /// Return alternate translations
  bool? get translate;
  @override

  /// Return the individual words with the verses
  bool? get words;
  @override
  @JsonKey(ignore: true)
  _$$_VersesRequestCopyWith<_$_VersesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

VersesResponse _$VersesResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return VersesResponseData.fromJson(json);
    case 'Merr':
      return VersesResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'VersesResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$VersesResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(VersesResponseData value)? $default, {
    TResult? Function(VersesResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersesResponseCopyWith<$Res> {
  factory $VersesResponseCopyWith(
          VersesResponse value, $Res Function(VersesResponse) then) =
      _$VersesResponseCopyWithImpl<$Res, VersesResponse>;
}

/// @nodoc
class _$VersesResponseCopyWithImpl<$Res, $Val extends VersesResponse>
    implements $VersesResponseCopyWith<$Res> {
  _$VersesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$VersesResponseDataCopyWith<$Res> {
  factory _$$VersesResponseDataCopyWith(_$VersesResponseData value,
          $Res Function(_$VersesResponseData) then) =
      __$$VersesResponseDataCopyWithImpl<$Res>;
  @useResult
  $Res call({int? chapter, int? page, int? total_pages, List<Verse>? verses});
}

/// @nodoc
class __$$VersesResponseDataCopyWithImpl<$Res>
    extends _$VersesResponseCopyWithImpl<$Res, _$VersesResponseData>
    implements _$$VersesResponseDataCopyWith<$Res> {
  __$$VersesResponseDataCopyWithImpl(
      _$VersesResponseData _value, $Res Function(_$VersesResponseData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chapter = freezed,
    Object? page = freezed,
    Object? total_pages = freezed,
    Object? verses = freezed,
  }) {
    return _then(_$VersesResponseData(
      chapter: freezed == chapter
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      total_pages: freezed == total_pages
          ? _value.total_pages
          : total_pages // ignore: cast_nullable_to_non_nullable
              as int?,
      verses: freezed == verses
          ? _value._verses
          : verses // ignore: cast_nullable_to_non_nullable
              as List<Verse>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersesResponseData implements VersesResponseData {
  const _$VersesResponseData(
      {this.chapter,
      this.page,
      this.total_pages,
      final List<Verse>? verses,
      final String? $type})
      : _verses = verses,
        $type = $type ?? 'default';

  factory _$VersesResponseData.fromJson(Map<String, dynamic> json) =>
      _$$VersesResponseDataFromJson(json);

  /// The chapter requested
  @override
  final int? chapter;

  /// The page requested
  @override
  final int? page;

  /// The total pages
  @override
  final int? total_pages;

  /// The verses on the page
  final List<Verse>? _verses;

  /// The verses on the page
  @override
  List<Verse>? get verses {
    final value = _verses;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'VersesResponse(chapter: $chapter, page: $page, total_pages: $total_pages, verses: $verses)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersesResponseData &&
            (identical(other.chapter, chapter) || other.chapter == chapter) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.total_pages, total_pages) ||
                other.total_pages == total_pages) &&
            const DeepCollectionEquality().equals(other._verses, _verses));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, chapter, page, total_pages,
      const DeepCollectionEquality().hash(_verses));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VersesResponseDataCopyWith<_$VersesResponseData> get copyWith =>
      __$$VersesResponseDataCopyWithImpl<_$VersesResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(chapter, page, total_pages, verses);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(chapter, page, total_pages, verses);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(chapter, page, total_pages, verses);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(VersesResponseData value)? $default, {
    TResult? Function(VersesResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$VersesResponseDataToJson(
      this,
    );
  }
}

abstract class VersesResponseData implements VersesResponse {
  const factory VersesResponseData(
      {final int? chapter,
      final int? page,
      final int? total_pages,
      final List<Verse>? verses}) = _$VersesResponseData;

  factory VersesResponseData.fromJson(Map<String, dynamic> json) =
      _$VersesResponseData.fromJson;

  /// The chapter requested
  int? get chapter;

  /// The page requested
  int? get page;

  /// The total pages
  int? get total_pages;

  /// The verses on the page
  List<Verse>? get verses;
  @JsonKey(ignore: true)
  _$$VersesResponseDataCopyWith<_$VersesResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VersesResponseMerrCopyWith<$Res> {
  factory _$$VersesResponseMerrCopyWith(_$VersesResponseMerr value,
          $Res Function(_$VersesResponseMerr) then) =
      __$$VersesResponseMerrCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$VersesResponseMerrCopyWithImpl<$Res>
    extends _$VersesResponseCopyWithImpl<$Res, _$VersesResponseMerr>
    implements _$$VersesResponseMerrCopyWith<$Res> {
  __$$VersesResponseMerrCopyWithImpl(
      _$VersesResponseMerr _value, $Res Function(_$VersesResponseMerr) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$VersesResponseMerr(
      body: freezed == body
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersesResponseMerr implements VersesResponseMerr {
  const _$VersesResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$VersesResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$VersesResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'VersesResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersesResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VersesResponseMerrCopyWith<_$VersesResponseMerr> get copyWith =>
      __$$VersesResponseMerrCopyWithImpl<_$VersesResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult? Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(VersesResponseData value)? $default, {
    TResult? Function(VersesResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$VersesResponseMerrToJson(
      this,
    );
  }
}

abstract class VersesResponseMerr implements VersesResponse {
  const factory VersesResponseMerr({final Map<String, dynamic>? body}) =
      _$VersesResponseMerr;

  factory VersesResponseMerr.fromJson(Map<String, dynamic> json) =
      _$VersesResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$VersesResponseMerrCopyWith<_$VersesResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Word _$WordFromJson(Map<String, dynamic> json) {
  return _Word.fromJson(json);
}

/// @nodoc
mixin _$Word {
  /// The arabic text for this word
  String? get text => throw _privateConstructorUsedError;

  /// The translated text
  String? get translation => throw _privateConstructorUsedError;

  /// The QCF v2 font code
  String? get code => throw _privateConstructorUsedError;

  /// The page number
  int? get page => throw _privateConstructorUsedError;

  /// The position of the word
  int? get position => throw _privateConstructorUsedError;

  /// The transliteration text
  String? get transliteration => throw _privateConstructorUsedError;

  /// The character type e.g word, end
  String? get char_type => throw _privateConstructorUsedError;

  /// The id of the word within the verse
  int? get id => throw _privateConstructorUsedError;

  /// The line number
  int? get line => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordCopyWith<Word> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordCopyWith<$Res> {
  factory $WordCopyWith(Word value, $Res Function(Word) then) =
      _$WordCopyWithImpl<$Res, Word>;
  @useResult
  $Res call(
      {String? text,
      String? translation,
      String? code,
      int? page,
      int? position,
      String? transliteration,
      String? char_type,
      int? id,
      int? line});
}

/// @nodoc
class _$WordCopyWithImpl<$Res, $Val extends Word>
    implements $WordCopyWith<$Res> {
  _$WordCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = freezed,
    Object? translation = freezed,
    Object? code = freezed,
    Object? page = freezed,
    Object? position = freezed,
    Object? transliteration = freezed,
    Object? char_type = freezed,
    Object? id = freezed,
    Object? line = freezed,
  }) {
    return _then(_value.copyWith(
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translation: freezed == translation
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int?,
      transliteration: freezed == transliteration
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
      char_type: freezed == char_type
          ? _value.char_type
          : char_type // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WordCopyWith<$Res> implements $WordCopyWith<$Res> {
  factory _$$_WordCopyWith(_$_Word value, $Res Function(_$_Word) then) =
      __$$_WordCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? text,
      String? translation,
      String? code,
      int? page,
      int? position,
      String? transliteration,
      String? char_type,
      int? id,
      int? line});
}

/// @nodoc
class __$$_WordCopyWithImpl<$Res> extends _$WordCopyWithImpl<$Res, _$_Word>
    implements _$$_WordCopyWith<$Res> {
  __$$_WordCopyWithImpl(_$_Word _value, $Res Function(_$_Word) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = freezed,
    Object? translation = freezed,
    Object? code = freezed,
    Object? page = freezed,
    Object? position = freezed,
    Object? transliteration = freezed,
    Object? char_type = freezed,
    Object? id = freezed,
    Object? line = freezed,
  }) {
    return _then(_$_Word(
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translation: freezed == translation
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      page: freezed == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int?,
      transliteration: freezed == transliteration
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
      char_type: freezed == char_type
          ? _value.char_type
          : char_type // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Word implements _Word {
  const _$_Word(
      {this.text,
      this.translation,
      this.code,
      this.page,
      this.position,
      this.transliteration,
      this.char_type,
      this.id,
      this.line});

  factory _$_Word.fromJson(Map<String, dynamic> json) => _$$_WordFromJson(json);

  /// The arabic text for this word
  @override
  final String? text;

  /// The translated text
  @override
  final String? translation;

  /// The QCF v2 font code
  @override
  final String? code;

  /// The page number
  @override
  final int? page;

  /// The position of the word
  @override
  final int? position;

  /// The transliteration text
  @override
  final String? transliteration;

  /// The character type e.g word, end
  @override
  final String? char_type;

  /// The id of the word within the verse
  @override
  final int? id;

  /// The line number
  @override
  final int? line;

  @override
  String toString() {
    return 'Word(text: $text, translation: $translation, code: $code, page: $page, position: $position, transliteration: $transliteration, char_type: $char_type, id: $id, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Word &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.translation, translation) ||
                other.translation == translation) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.transliteration, transliteration) ||
                other.transliteration == transliteration) &&
            (identical(other.char_type, char_type) ||
                other.char_type == char_type) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.line, line) || other.line == line));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, text, translation, code, page,
      position, transliteration, char_type, id, line);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WordCopyWith<_$_Word> get copyWith =>
      __$$_WordCopyWithImpl<_$_Word>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WordToJson(
      this,
    );
  }
}

abstract class _Word implements Word {
  const factory _Word(
      {final String? text,
      final String? translation,
      final String? code,
      final int? page,
      final int? position,
      final String? transliteration,
      final String? char_type,
      final int? id,
      final int? line}) = _$_Word;

  factory _Word.fromJson(Map<String, dynamic> json) = _$_Word.fromJson;

  @override

  /// The arabic text for this word
  String? get text;
  @override

  /// The translated text
  String? get translation;
  @override

  /// The QCF v2 font code
  String? get code;
  @override

  /// The page number
  int? get page;
  @override

  /// The position of the word
  int? get position;
  @override

  /// The transliteration text
  String? get transliteration;
  @override

  /// The character type e.g word, end
  String? get char_type;
  @override

  /// The id of the word within the verse
  int? get id;
  @override

  /// The line number
  int? get line;
  @override
  @JsonKey(ignore: true)
  _$$_WordCopyWith<_$_Word> get copyWith => throw _privateConstructorUsedError;
}
