// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'quran.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Chapter _$ChapterFromJson(Map<String, dynamic> json) {
  return _Chapter.fromJson(json);
}

/// @nodoc
mixin _$Chapter {
  /// The complex name of the chapter
  String? get complex_name => throw _privateConstructorUsedError;

  /// The id of the chapter as a number e.g 1
  int? get id => throw _privateConstructorUsedError;

  /// The simple name of the chapter
  String? get name => throw _privateConstructorUsedError;

  /// The place of revelation
  String? get revelation_place => throw _privateConstructorUsedError;

  /// The translated name
  String? get translated_name => throw _privateConstructorUsedError;

  /// The arabic name of the chapter
  String? get arabic_name => throw _privateConstructorUsedError;

  /// The pages from and to e.g 1, 1
  List<int>? get pages => throw _privateConstructorUsedError;

  /// Should the chapter start with bismillah
  bool? get prefix_bismillah => throw _privateConstructorUsedError;

  /// The order in which it was revealed
  int? get revelation_order => throw _privateConstructorUsedError;

  /// The number of verses in the chapter
  int? get verses => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChapterCopyWith<Chapter> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChapterCopyWith<$Res> {
  factory $ChapterCopyWith(Chapter value, $Res Function(Chapter) then) =
      _$ChapterCopyWithImpl<$Res>;
  $Res call(
      {String? complex_name,
      int? id,
      String? name,
      String? revelation_place,
      String? translated_name,
      String? arabic_name,
      List<int>? pages,
      bool? prefix_bismillah,
      int? revelation_order,
      int? verses});
}

/// @nodoc
class _$ChapterCopyWithImpl<$Res> implements $ChapterCopyWith<$Res> {
  _$ChapterCopyWithImpl(this._value, this._then);

  final Chapter _value;
  // ignore: unused_field
  final $Res Function(Chapter) _then;

  @override
  $Res call({
    Object? complex_name = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? revelation_place = freezed,
    Object? translated_name = freezed,
    Object? arabic_name = freezed,
    Object? pages = freezed,
    Object? prefix_bismillah = freezed,
    Object? revelation_order = freezed,
    Object? verses = freezed,
  }) {
    return _then(_value.copyWith(
      complex_name: complex_name == freezed
          ? _value.complex_name
          : complex_name // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      revelation_place: revelation_place == freezed
          ? _value.revelation_place
          : revelation_place // ignore: cast_nullable_to_non_nullable
              as String?,
      translated_name: translated_name == freezed
          ? _value.translated_name
          : translated_name // ignore: cast_nullable_to_non_nullable
              as String?,
      arabic_name: arabic_name == freezed
          ? _value.arabic_name
          : arabic_name // ignore: cast_nullable_to_non_nullable
              as String?,
      pages: pages == freezed
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      prefix_bismillah: prefix_bismillah == freezed
          ? _value.prefix_bismillah
          : prefix_bismillah // ignore: cast_nullable_to_non_nullable
              as bool?,
      revelation_order: revelation_order == freezed
          ? _value.revelation_order
          : revelation_order // ignore: cast_nullable_to_non_nullable
              as int?,
      verses: verses == freezed
          ? _value.verses
          : verses // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
abstract class _$$_ChapterCopyWith<$Res> implements $ChapterCopyWith<$Res> {
  factory _$$_ChapterCopyWith(
          _$_Chapter value, $Res Function(_$_Chapter) then) =
      __$$_ChapterCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? complex_name,
      int? id,
      String? name,
      String? revelation_place,
      String? translated_name,
      String? arabic_name,
      List<int>? pages,
      bool? prefix_bismillah,
      int? revelation_order,
      int? verses});
}

/// @nodoc
class __$$_ChapterCopyWithImpl<$Res> extends _$ChapterCopyWithImpl<$Res>
    implements _$$_ChapterCopyWith<$Res> {
  __$$_ChapterCopyWithImpl(_$_Chapter _value, $Res Function(_$_Chapter) _then)
      : super(_value, (v) => _then(v as _$_Chapter));

  @override
  _$_Chapter get _value => super._value as _$_Chapter;

  @override
  $Res call({
    Object? complex_name = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? revelation_place = freezed,
    Object? translated_name = freezed,
    Object? arabic_name = freezed,
    Object? pages = freezed,
    Object? prefix_bismillah = freezed,
    Object? revelation_order = freezed,
    Object? verses = freezed,
  }) {
    return _then(_$_Chapter(
      complex_name: complex_name == freezed
          ? _value.complex_name
          : complex_name // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      revelation_place: revelation_place == freezed
          ? _value.revelation_place
          : revelation_place // ignore: cast_nullable_to_non_nullable
              as String?,
      translated_name: translated_name == freezed
          ? _value.translated_name
          : translated_name // ignore: cast_nullable_to_non_nullable
              as String?,
      arabic_name: arabic_name == freezed
          ? _value.arabic_name
          : arabic_name // ignore: cast_nullable_to_non_nullable
              as String?,
      pages: pages == freezed
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      prefix_bismillah: prefix_bismillah == freezed
          ? _value.prefix_bismillah
          : prefix_bismillah // ignore: cast_nullable_to_non_nullable
              as bool?,
      revelation_order: revelation_order == freezed
          ? _value.revelation_order
          : revelation_order // ignore: cast_nullable_to_non_nullable
              as int?,
      verses: verses == freezed
          ? _value.verses
          : verses // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Chapter implements _Chapter {
  const _$_Chapter(
      {this.complex_name,
      this.id,
      this.name,
      this.revelation_place,
      this.translated_name,
      this.arabic_name,
      final List<int>? pages,
      this.prefix_bismillah,
      this.revelation_order,
      this.verses})
      : _pages = pages;

  factory _$_Chapter.fromJson(Map<String, dynamic> json) =>
      _$$_ChapterFromJson(json);

  /// The complex name of the chapter
  @override
  final String? complex_name;

  /// The id of the chapter as a number e.g 1
  @override
  final int? id;

  /// The simple name of the chapter
  @override
  final String? name;

  /// The place of revelation
  @override
  final String? revelation_place;

  /// The translated name
  @override
  final String? translated_name;

  /// The arabic name of the chapter
  @override
  final String? arabic_name;

  /// The pages from and to e.g 1, 1
  final List<int>? _pages;

  /// The pages from and to e.g 1, 1
  @override
  List<int>? get pages {
    final value = _pages;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Should the chapter start with bismillah
  @override
  final bool? prefix_bismillah;

  /// The order in which it was revealed
  @override
  final int? revelation_order;

  /// The number of verses in the chapter
  @override
  final int? verses;

  @override
  String toString() {
    return 'Chapter(complex_name: $complex_name, id: $id, name: $name, revelation_place: $revelation_place, translated_name: $translated_name, arabic_name: $arabic_name, pages: $pages, prefix_bismillah: $prefix_bismillah, revelation_order: $revelation_order, verses: $verses)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Chapter &&
            const DeepCollectionEquality()
                .equals(other.complex_name, complex_name) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.revelation_place, revelation_place) &&
            const DeepCollectionEquality()
                .equals(other.translated_name, translated_name) &&
            const DeepCollectionEquality()
                .equals(other.arabic_name, arabic_name) &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            const DeepCollectionEquality()
                .equals(other.prefix_bismillah, prefix_bismillah) &&
            const DeepCollectionEquality()
                .equals(other.revelation_order, revelation_order) &&
            const DeepCollectionEquality().equals(other.verses, verses));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(complex_name),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(revelation_place),
      const DeepCollectionEquality().hash(translated_name),
      const DeepCollectionEquality().hash(arabic_name),
      const DeepCollectionEquality().hash(_pages),
      const DeepCollectionEquality().hash(prefix_bismillah),
      const DeepCollectionEquality().hash(revelation_order),
      const DeepCollectionEquality().hash(verses));

  @JsonKey(ignore: true)
  @override
  _$$_ChapterCopyWith<_$_Chapter> get copyWith =>
      __$$_ChapterCopyWithImpl<_$_Chapter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChapterToJson(
      this,
    );
  }
}

abstract class _Chapter implements Chapter {
  const factory _Chapter(
      {final String? complex_name,
      final int? id,
      final String? name,
      final String? revelation_place,
      final String? translated_name,
      final String? arabic_name,
      final List<int>? pages,
      final bool? prefix_bismillah,
      final int? revelation_order,
      final int? verses}) = _$_Chapter;

  factory _Chapter.fromJson(Map<String, dynamic> json) = _$_Chapter.fromJson;

  @override

  /// The complex name of the chapter
  String? get complex_name;
  @override

  /// The id of the chapter as a number e.g 1
  int? get id;
  @override

  /// The simple name of the chapter
  String? get name;
  @override

  /// The place of revelation
  String? get revelation_place;
  @override

  /// The translated name
  String? get translated_name;
  @override

  /// The arabic name of the chapter
  String? get arabic_name;
  @override

  /// The pages from and to e.g 1, 1
  List<int>? get pages;
  @override

  /// Should the chapter start with bismillah
  bool? get prefix_bismillah;
  @override

  /// The order in which it was revealed
  int? get revelation_order;
  @override

  /// The number of verses in the chapter
  int? get verses;
  @override
  @JsonKey(ignore: true)
  _$$_ChapterCopyWith<_$_Chapter> get copyWith =>
      throw _privateConstructorUsedError;
}

ChaptersRequest _$ChaptersRequestFromJson(Map<String, dynamic> json) {
  return _ChaptersRequest.fromJson(json);
}

/// @nodoc
mixin _$ChaptersRequest {
  /// Specify the language e.g en
  String? get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChaptersRequestCopyWith<ChaptersRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChaptersRequestCopyWith<$Res> {
  factory $ChaptersRequestCopyWith(
          ChaptersRequest value, $Res Function(ChaptersRequest) then) =
      _$ChaptersRequestCopyWithImpl<$Res>;
  $Res call({String? language});
}

/// @nodoc
class _$ChaptersRequestCopyWithImpl<$Res>
    implements $ChaptersRequestCopyWith<$Res> {
  _$ChaptersRequestCopyWithImpl(this._value, this._then);

  final ChaptersRequest _value;
  // ignore: unused_field
  final $Res Function(ChaptersRequest) _then;

  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_ChaptersRequestCopyWith<$Res>
    implements $ChaptersRequestCopyWith<$Res> {
  factory _$$_ChaptersRequestCopyWith(
          _$_ChaptersRequest value, $Res Function(_$_ChaptersRequest) then) =
      __$$_ChaptersRequestCopyWithImpl<$Res>;
  @override
  $Res call({String? language});
}

/// @nodoc
class __$$_ChaptersRequestCopyWithImpl<$Res>
    extends _$ChaptersRequestCopyWithImpl<$Res>
    implements _$$_ChaptersRequestCopyWith<$Res> {
  __$$_ChaptersRequestCopyWithImpl(
      _$_ChaptersRequest _value, $Res Function(_$_ChaptersRequest) _then)
      : super(_value, (v) => _then(v as _$_ChaptersRequest));

  @override
  _$_ChaptersRequest get _value => super._value as _$_ChaptersRequest;

  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_$_ChaptersRequest(
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ChaptersRequest implements _ChaptersRequest {
  const _$_ChaptersRequest({this.language});

  factory _$_ChaptersRequest.fromJson(Map<String, dynamic> json) =>
      _$$_ChaptersRequestFromJson(json);

  /// Specify the language e.g en
  @override
  final String? language;

  @override
  String toString() {
    return 'ChaptersRequest(language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChaptersRequest &&
            const DeepCollectionEquality().equals(other.language, language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(language));

  @JsonKey(ignore: true)
  @override
  _$$_ChaptersRequestCopyWith<_$_ChaptersRequest> get copyWith =>
      __$$_ChaptersRequestCopyWithImpl<_$_ChaptersRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChaptersRequestToJson(
      this,
    );
  }
}

abstract class _ChaptersRequest implements ChaptersRequest {
  const factory _ChaptersRequest({final String? language}) = _$_ChaptersRequest;

  factory _ChaptersRequest.fromJson(Map<String, dynamic> json) =
      _$_ChaptersRequest.fromJson;

  @override

  /// Specify the language e.g en
  String? get language;
  @override
  @JsonKey(ignore: true)
  _$$_ChaptersRequestCopyWith<_$_ChaptersRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

ChaptersResponse _$ChaptersResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return ChaptersResponseData.fromJson(json);
    case 'Merr':
      return ChaptersResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChaptersResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChaptersResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChaptersResponseCopyWith<$Res> {
  factory $ChaptersResponseCopyWith(
          ChaptersResponse value, $Res Function(ChaptersResponse) then) =
      _$ChaptersResponseCopyWithImpl<$Res>;
}

/// @nodoc
class _$ChaptersResponseCopyWithImpl<$Res>
    implements $ChaptersResponseCopyWith<$Res> {
  _$ChaptersResponseCopyWithImpl(this._value, this._then);

  final ChaptersResponse _value;
  // ignore: unused_field
  final $Res Function(ChaptersResponse) _then;
}

/// @nodoc
abstract class _$$ChaptersResponseDataCopyWith<$Res> {
  factory _$$ChaptersResponseDataCopyWith(_$ChaptersResponseData value,
          $Res Function(_$ChaptersResponseData) then) =
      __$$ChaptersResponseDataCopyWithImpl<$Res>;
  $Res call({List<Chapter>? chapters});
}

/// @nodoc
class __$$ChaptersResponseDataCopyWithImpl<$Res>
    extends _$ChaptersResponseCopyWithImpl<$Res>
    implements _$$ChaptersResponseDataCopyWith<$Res> {
  __$$ChaptersResponseDataCopyWithImpl(_$ChaptersResponseData _value,
      $Res Function(_$ChaptersResponseData) _then)
      : super(_value, (v) => _then(v as _$ChaptersResponseData));

  @override
  _$ChaptersResponseData get _value => super._value as _$ChaptersResponseData;

  @override
  $Res call({
    Object? chapters = freezed,
  }) {
    return _then(_$ChaptersResponseData(
      chapters: chapters == freezed
          ? _value._chapters
          : chapters // ignore: cast_nullable_to_non_nullable
              as List<Chapter>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChaptersResponseData implements ChaptersResponseData {
  const _$ChaptersResponseData(
      {final List<Chapter>? chapters, final String? $type})
      : _chapters = chapters,
        $type = $type ?? 'default';

  factory _$ChaptersResponseData.fromJson(Map<String, dynamic> json) =>
      _$$ChaptersResponseDataFromJson(json);

  final List<Chapter>? _chapters;
  @override
  List<Chapter>? get chapters {
    final value = _chapters;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChaptersResponse(chapters: $chapters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChaptersResponseData &&
            const DeepCollectionEquality().equals(other._chapters, _chapters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_chapters));

  @JsonKey(ignore: true)
  @override
  _$$ChaptersResponseDataCopyWith<_$ChaptersResponseData> get copyWith =>
      __$$ChaptersResponseDataCopyWithImpl<_$ChaptersResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(chapters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(chapters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(chapters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChaptersResponseDataToJson(
      this,
    );
  }
}

abstract class ChaptersResponseData implements ChaptersResponse {
  const factory ChaptersResponseData({final List<Chapter>? chapters}) =
      _$ChaptersResponseData;

  factory ChaptersResponseData.fromJson(Map<String, dynamic> json) =
      _$ChaptersResponseData.fromJson;

  List<Chapter>? get chapters;
  @JsonKey(ignore: true)
  _$$ChaptersResponseDataCopyWith<_$ChaptersResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChaptersResponseMerrCopyWith<$Res> {
  factory _$$ChaptersResponseMerrCopyWith(_$ChaptersResponseMerr value,
          $Res Function(_$ChaptersResponseMerr) then) =
      __$$ChaptersResponseMerrCopyWithImpl<$Res>;
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$ChaptersResponseMerrCopyWithImpl<$Res>
    extends _$ChaptersResponseCopyWithImpl<$Res>
    implements _$$ChaptersResponseMerrCopyWith<$Res> {
  __$$ChaptersResponseMerrCopyWithImpl(_$ChaptersResponseMerr _value,
      $Res Function(_$ChaptersResponseMerr) _then)
      : super(_value, (v) => _then(v as _$ChaptersResponseMerr));

  @override
  _$ChaptersResponseMerr get _value => super._value as _$ChaptersResponseMerr;

  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$ChaptersResponseMerr(
      body: body == freezed
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChaptersResponseMerr implements ChaptersResponseMerr {
  const _$ChaptersResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$ChaptersResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$ChaptersResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChaptersResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChaptersResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  _$$ChaptersResponseMerrCopyWith<_$ChaptersResponseMerr> get copyWith =>
      __$$ChaptersResponseMerrCopyWithImpl<_$ChaptersResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters) $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<Chapter>? chapters)? $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(ChaptersResponseData value) $default, {
    required TResult Function(ChaptersResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(ChaptersResponseData value)? $default, {
    TResult Function(ChaptersResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChaptersResponseMerrToJson(
      this,
    );
  }
}

abstract class ChaptersResponseMerr implements ChaptersResponse {
  const factory ChaptersResponseMerr({final Map<String, dynamic>? body}) =
      _$ChaptersResponseMerr;

  factory ChaptersResponseMerr.fromJson(Map<String, dynamic> json) =
      _$ChaptersResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$ChaptersResponseMerrCopyWith<_$ChaptersResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Interpretation _$InterpretationFromJson(Map<String, dynamic> json) {
  return _Interpretation.fromJson(json);
}

/// @nodoc
mixin _$Interpretation {
  /// The unique id of the interpretation
  int? get id => throw _privateConstructorUsedError;

  /// The source of the interpretation
  String? get source => throw _privateConstructorUsedError;

  /// The translated text
  String? get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InterpretationCopyWith<Interpretation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InterpretationCopyWith<$Res> {
  factory $InterpretationCopyWith(
          Interpretation value, $Res Function(Interpretation) then) =
      _$InterpretationCopyWithImpl<$Res>;
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class _$InterpretationCopyWithImpl<$Res>
    implements $InterpretationCopyWith<$Res> {
  _$InterpretationCopyWithImpl(this._value, this._then);

  final Interpretation _value;
  // ignore: unused_field
  final $Res Function(Interpretation) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: source == freezed
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_InterpretationCopyWith<$Res>
    implements $InterpretationCopyWith<$Res> {
  factory _$$_InterpretationCopyWith(
          _$_Interpretation value, $Res Function(_$_Interpretation) then) =
      __$$_InterpretationCopyWithImpl<$Res>;
  @override
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class __$$_InterpretationCopyWithImpl<$Res>
    extends _$InterpretationCopyWithImpl<$Res>
    implements _$$_InterpretationCopyWith<$Res> {
  __$$_InterpretationCopyWithImpl(
      _$_Interpretation _value, $Res Function(_$_Interpretation) _then)
      : super(_value, (v) => _then(v as _$_Interpretation));

  @override
  _$_Interpretation get _value => super._value as _$_Interpretation;

  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_$_Interpretation(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: source == freezed
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Interpretation implements _Interpretation {
  const _$_Interpretation({this.id, this.source, this.text});

  factory _$_Interpretation.fromJson(Map<String, dynamic> json) =>
      _$$_InterpretationFromJson(json);

  /// The unique id of the interpretation
  @override
  final int? id;

  /// The source of the interpretation
  @override
  final String? source;

  /// The translated text
  @override
  final String? text;

  @override
  String toString() {
    return 'Interpretation(id: $id, source: $source, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Interpretation &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.source, source) &&
            const DeepCollectionEquality().equals(other.text, text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(source),
      const DeepCollectionEquality().hash(text));

  @JsonKey(ignore: true)
  @override
  _$$_InterpretationCopyWith<_$_Interpretation> get copyWith =>
      __$$_InterpretationCopyWithImpl<_$_Interpretation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InterpretationToJson(
      this,
    );
  }
}

abstract class _Interpretation implements Interpretation {
  const factory _Interpretation(
      {final int? id,
      final String? source,
      final String? text}) = _$_Interpretation;

  factory _Interpretation.fromJson(Map<String, dynamic> json) =
      _$_Interpretation.fromJson;

  @override

  /// The unique id of the interpretation
  int? get id;
  @override

  /// The source of the interpretation
  String? get source;
  @override

  /// The translated text
  String? get text;
  @override
  @JsonKey(ignore: true)
  _$$_InterpretationCopyWith<_$_Interpretation> get copyWith =>
      throw _privateConstructorUsedError;
}

Result _$ResultFromJson(Map<String, dynamic> json) {
  return _Result.fromJson(json);
}

/// @nodoc
mixin _$Result {
  /// The associated arabic text
  String? get text => throw _privateConstructorUsedError;

  /// The related translations to the text
  List<Translation>? get translations => throw _privateConstructorUsedError;

  /// The unique verse id across the Quran
  int? get verse_id => throw _privateConstructorUsedError;

  /// The verse key e.g 1:1
  String? get verse_key => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResultCopyWith<Result> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResultCopyWith<$Res> {
  factory $ResultCopyWith(Result value, $Res Function(Result) then) =
      _$ResultCopyWithImpl<$Res>;
  $Res call(
      {String? text,
      List<Translation>? translations,
      int? verse_id,
      String? verse_key});
}

/// @nodoc
class _$ResultCopyWithImpl<$Res> implements $ResultCopyWith<$Res> {
  _$ResultCopyWithImpl(this._value, this._then);

  final Result _value;
  // ignore: unused_field
  final $Res Function(Result) _then;

  @override
  $Res call({
    Object? text = freezed,
    Object? translations = freezed,
    Object? verse_id = freezed,
    Object? verse_key = freezed,
  }) {
    return _then(_value.copyWith(
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: translations == freezed
          ? _value.translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      verse_id: verse_id == freezed
          ? _value.verse_id
          : verse_id // ignore: cast_nullable_to_non_nullable
              as int?,
      verse_key: verse_key == freezed
          ? _value.verse_key
          : verse_key // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_ResultCopyWith<$Res> implements $ResultCopyWith<$Res> {
  factory _$$_ResultCopyWith(_$_Result value, $Res Function(_$_Result) then) =
      __$$_ResultCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? text,
      List<Translation>? translations,
      int? verse_id,
      String? verse_key});
}

/// @nodoc
class __$$_ResultCopyWithImpl<$Res> extends _$ResultCopyWithImpl<$Res>
    implements _$$_ResultCopyWith<$Res> {
  __$$_ResultCopyWithImpl(_$_Result _value, $Res Function(_$_Result) _then)
      : super(_value, (v) => _then(v as _$_Result));

  @override
  _$_Result get _value => super._value as _$_Result;

  @override
  $Res call({
    Object? text = freezed,
    Object? translations = freezed,
    Object? verse_id = freezed,
    Object? verse_key = freezed,
  }) {
    return _then(_$_Result(
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translations: translations == freezed
          ? _value._translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      verse_id: verse_id == freezed
          ? _value.verse_id
          : verse_id // ignore: cast_nullable_to_non_nullable
              as int?,
      verse_key: verse_key == freezed
          ? _value.verse_key
          : verse_key // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Result implements _Result {
  const _$_Result(
      {this.text,
      final List<Translation>? translations,
      this.verse_id,
      this.verse_key})
      : _translations = translations;

  factory _$_Result.fromJson(Map<String, dynamic> json) =>
      _$$_ResultFromJson(json);

  /// The associated arabic text
  @override
  final String? text;

  /// The related translations to the text
  final List<Translation>? _translations;

  /// The related translations to the text
  @override
  List<Translation>? get translations {
    final value = _translations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The unique verse id across the Quran
  @override
  final int? verse_id;

  /// The verse key e.g 1:1
  @override
  final String? verse_key;

  @override
  String toString() {
    return 'Result(text: $text, translations: $translations, verse_id: $verse_id, verse_key: $verse_key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Result &&
            const DeepCollectionEquality().equals(other.text, text) &&
            const DeepCollectionEquality()
                .equals(other._translations, _translations) &&
            const DeepCollectionEquality().equals(other.verse_id, verse_id) &&
            const DeepCollectionEquality().equals(other.verse_key, verse_key));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(text),
      const DeepCollectionEquality().hash(_translations),
      const DeepCollectionEquality().hash(verse_id),
      const DeepCollectionEquality().hash(verse_key));

  @JsonKey(ignore: true)
  @override
  _$$_ResultCopyWith<_$_Result> get copyWith =>
      __$$_ResultCopyWithImpl<_$_Result>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ResultToJson(
      this,
    );
  }
}

abstract class _Result implements Result {
  const factory _Result(
      {final String? text,
      final List<Translation>? translations,
      final int? verse_id,
      final String? verse_key}) = _$_Result;

  factory _Result.fromJson(Map<String, dynamic> json) = _$_Result.fromJson;

  @override

  /// The associated arabic text
  String? get text;
  @override

  /// The related translations to the text
  List<Translation>? get translations;
  @override

  /// The unique verse id across the Quran
  int? get verse_id;
  @override

  /// The verse key e.g 1:1
  String? get verse_key;
  @override
  @JsonKey(ignore: true)
  _$$_ResultCopyWith<_$_Result> get copyWith =>
      throw _privateConstructorUsedError;
}

SearchRequest _$SearchRequestFromJson(Map<String, dynamic> json) {
  return _SearchRequest.fromJson(json);
}

/// @nodoc
mixin _$SearchRequest {
  /// The language for translation
  String? get language => throw _privateConstructorUsedError;

  /// The number of results to return
  int? get limit => throw _privateConstructorUsedError;

  /// The pagination number
  int? get page => throw _privateConstructorUsedError;

  /// The query to ask
  String? get query => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SearchRequestCopyWith<SearchRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchRequestCopyWith<$Res> {
  factory $SearchRequestCopyWith(
          SearchRequest value, $Res Function(SearchRequest) then) =
      _$SearchRequestCopyWithImpl<$Res>;
  $Res call({String? language, int? limit, int? page, String? query});
}

/// @nodoc
class _$SearchRequestCopyWithImpl<$Res>
    implements $SearchRequestCopyWith<$Res> {
  _$SearchRequestCopyWithImpl(this._value, this._then);

  final SearchRequest _value;
  // ignore: unused_field
  final $Res Function(SearchRequest) _then;

  @override
  $Res call({
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? query = freezed,
  }) {
    return _then(_value.copyWith(
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: query == freezed
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_SearchRequestCopyWith<$Res>
    implements $SearchRequestCopyWith<$Res> {
  factory _$$_SearchRequestCopyWith(
          _$_SearchRequest value, $Res Function(_$_SearchRequest) then) =
      __$$_SearchRequestCopyWithImpl<$Res>;
  @override
  $Res call({String? language, int? limit, int? page, String? query});
}

/// @nodoc
class __$$_SearchRequestCopyWithImpl<$Res>
    extends _$SearchRequestCopyWithImpl<$Res>
    implements _$$_SearchRequestCopyWith<$Res> {
  __$$_SearchRequestCopyWithImpl(
      _$_SearchRequest _value, $Res Function(_$_SearchRequest) _then)
      : super(_value, (v) => _then(v as _$_SearchRequest));

  @override
  _$_SearchRequest get _value => super._value as _$_SearchRequest;

  @override
  $Res call({
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? query = freezed,
  }) {
    return _then(_$_SearchRequest(
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: query == freezed
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SearchRequest implements _SearchRequest {
  const _$_SearchRequest({this.language, this.limit, this.page, this.query});

  factory _$_SearchRequest.fromJson(Map<String, dynamic> json) =>
      _$$_SearchRequestFromJson(json);

  /// The language for translation
  @override
  final String? language;

  /// The number of results to return
  @override
  final int? limit;

  /// The pagination number
  @override
  final int? page;

  /// The query to ask
  @override
  final String? query;

  @override
  String toString() {
    return 'SearchRequest(language: $language, limit: $limit, page: $page, query: $query)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SearchRequest &&
            const DeepCollectionEquality().equals(other.language, language) &&
            const DeepCollectionEquality().equals(other.limit, limit) &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality().equals(other.query, query));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(language),
      const DeepCollectionEquality().hash(limit),
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(query));

  @JsonKey(ignore: true)
  @override
  _$$_SearchRequestCopyWith<_$_SearchRequest> get copyWith =>
      __$$_SearchRequestCopyWithImpl<_$_SearchRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SearchRequestToJson(
      this,
    );
  }
}

abstract class _SearchRequest implements SearchRequest {
  const factory _SearchRequest(
      {final String? language,
      final int? limit,
      final int? page,
      final String? query}) = _$_SearchRequest;

  factory _SearchRequest.fromJson(Map<String, dynamic> json) =
      _$_SearchRequest.fromJson;

  @override

  /// The language for translation
  String? get language;
  @override

  /// The number of results to return
  int? get limit;
  @override

  /// The pagination number
  int? get page;
  @override

  /// The query to ask
  String? get query;
  @override
  @JsonKey(ignore: true)
  _$$_SearchRequestCopyWith<_$_SearchRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

SearchResponse _$SearchResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return SearchResponseData.fromJson(json);
    case 'Merr':
      return SearchResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SearchResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SearchResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchResponseCopyWith<$Res> {
  factory $SearchResponseCopyWith(
          SearchResponse value, $Res Function(SearchResponse) then) =
      _$SearchResponseCopyWithImpl<$Res>;
}

/// @nodoc
class _$SearchResponseCopyWithImpl<$Res>
    implements $SearchResponseCopyWith<$Res> {
  _$SearchResponseCopyWithImpl(this._value, this._then);

  final SearchResponse _value;
  // ignore: unused_field
  final $Res Function(SearchResponse) _then;
}

/// @nodoc
abstract class _$$SearchResponseDataCopyWith<$Res> {
  factory _$$SearchResponseDataCopyWith(_$SearchResponseData value,
          $Res Function(_$SearchResponseData) then) =
      __$$SearchResponseDataCopyWithImpl<$Res>;
  $Res call(
      {int? page,
      String? query,
      List<Result>? results,
      int? total_pages,
      int? total_results});
}

/// @nodoc
class __$$SearchResponseDataCopyWithImpl<$Res>
    extends _$SearchResponseCopyWithImpl<$Res>
    implements _$$SearchResponseDataCopyWith<$Res> {
  __$$SearchResponseDataCopyWithImpl(
      _$SearchResponseData _value, $Res Function(_$SearchResponseData) _then)
      : super(_value, (v) => _then(v as _$SearchResponseData));

  @override
  _$SearchResponseData get _value => super._value as _$SearchResponseData;

  @override
  $Res call({
    Object? page = freezed,
    Object? query = freezed,
    Object? results = freezed,
    Object? total_pages = freezed,
    Object? total_results = freezed,
  }) {
    return _then(_$SearchResponseData(
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      query: query == freezed
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String?,
      results: results == freezed
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Result>?,
      total_pages: total_pages == freezed
          ? _value.total_pages
          : total_pages // ignore: cast_nullable_to_non_nullable
              as int?,
      total_results: total_results == freezed
          ? _value.total_results
          : total_results // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SearchResponseData implements SearchResponseData {
  const _$SearchResponseData(
      {this.page,
      this.query,
      final List<Result>? results,
      this.total_pages,
      this.total_results,
      final String? $type})
      : _results = results,
        $type = $type ?? 'default';

  factory _$SearchResponseData.fromJson(Map<String, dynamic> json) =>
      _$$SearchResponseDataFromJson(json);

  /// The current page
  @override
  final int? page;

  /// The question asked
  @override
  final String? query;

  /// The results for the query
  final List<Result>? _results;

  /// The results for the query
  @override
  List<Result>? get results {
    final value = _results;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The total pages
  @override
  final int? total_pages;

  /// The total results returned
  @override
  final int? total_results;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SearchResponse(page: $page, query: $query, results: $results, total_pages: $total_pages, total_results: $total_results)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchResponseData &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality().equals(other.query, query) &&
            const DeepCollectionEquality().equals(other._results, _results) &&
            const DeepCollectionEquality()
                .equals(other.total_pages, total_pages) &&
            const DeepCollectionEquality()
                .equals(other.total_results, total_results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(query),
      const DeepCollectionEquality().hash(_results),
      const DeepCollectionEquality().hash(total_pages),
      const DeepCollectionEquality().hash(total_results));

  @JsonKey(ignore: true)
  @override
  _$$SearchResponseDataCopyWith<_$SearchResponseData> get copyWith =>
      __$$SearchResponseDataCopyWithImpl<_$SearchResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(page, query, results, total_pages, total_results);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(page, query, results, total_pages, total_results);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(page, query, results, total_pages, total_results);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SearchResponseDataToJson(
      this,
    );
  }
}

abstract class SearchResponseData implements SearchResponse {
  const factory SearchResponseData(
      {final int? page,
      final String? query,
      final List<Result>? results,
      final int? total_pages,
      final int? total_results}) = _$SearchResponseData;

  factory SearchResponseData.fromJson(Map<String, dynamic> json) =
      _$SearchResponseData.fromJson;

  /// The current page
  int? get page;

  /// The question asked
  String? get query;

  /// The results for the query
  List<Result>? get results;

  /// The total pages
  int? get total_pages;

  /// The total results returned
  int? get total_results;
  @JsonKey(ignore: true)
  _$$SearchResponseDataCopyWith<_$SearchResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchResponseMerrCopyWith<$Res> {
  factory _$$SearchResponseMerrCopyWith(_$SearchResponseMerr value,
          $Res Function(_$SearchResponseMerr) then) =
      __$$SearchResponseMerrCopyWithImpl<$Res>;
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$SearchResponseMerrCopyWithImpl<$Res>
    extends _$SearchResponseCopyWithImpl<$Res>
    implements _$$SearchResponseMerrCopyWith<$Res> {
  __$$SearchResponseMerrCopyWithImpl(
      _$SearchResponseMerr _value, $Res Function(_$SearchResponseMerr) _then)
      : super(_value, (v) => _then(v as _$SearchResponseMerr));

  @override
  _$SearchResponseMerr get _value => super._value as _$SearchResponseMerr;

  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$SearchResponseMerr(
      body: body == freezed
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SearchResponseMerr implements SearchResponseMerr {
  const _$SearchResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$SearchResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$SearchResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SearchResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  _$$SearchResponseMerrCopyWith<_$SearchResponseMerr> get copyWith =>
      __$$SearchResponseMerrCopyWithImpl<_$SearchResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int? page, String? query, List<Result>? results,
            int? total_pages, int? total_results)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SearchResponseData value) $default, {
    required TResult Function(SearchResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SearchResponseData value)? $default, {
    TResult Function(SearchResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SearchResponseMerrToJson(
      this,
    );
  }
}

abstract class SearchResponseMerr implements SearchResponse {
  const factory SearchResponseMerr({final Map<String, dynamic>? body}) =
      _$SearchResponseMerr;

  factory SearchResponseMerr.fromJson(Map<String, dynamic> json) =
      _$SearchResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$SearchResponseMerrCopyWith<_$SearchResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

SummaryRequest _$SummaryRequestFromJson(Map<String, dynamic> json) {
  return _SummaryRequest.fromJson(json);
}

/// @nodoc
mixin _$SummaryRequest {
  /// The chapter id e.g 1
  int? get chapter => throw _privateConstructorUsedError;

  /// Specify the language e.g en
  String? get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SummaryRequestCopyWith<SummaryRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SummaryRequestCopyWith<$Res> {
  factory $SummaryRequestCopyWith(
          SummaryRequest value, $Res Function(SummaryRequest) then) =
      _$SummaryRequestCopyWithImpl<$Res>;
  $Res call({int? chapter, String? language});
}

/// @nodoc
class _$SummaryRequestCopyWithImpl<$Res>
    implements $SummaryRequestCopyWith<$Res> {
  _$SummaryRequestCopyWithImpl(this._value, this._then);

  final SummaryRequest _value;
  // ignore: unused_field
  final $Res Function(SummaryRequest) _then;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_SummaryRequestCopyWith<$Res>
    implements $SummaryRequestCopyWith<$Res> {
  factory _$$_SummaryRequestCopyWith(
          _$_SummaryRequest value, $Res Function(_$_SummaryRequest) then) =
      __$$_SummaryRequestCopyWithImpl<$Res>;
  @override
  $Res call({int? chapter, String? language});
}

/// @nodoc
class __$$_SummaryRequestCopyWithImpl<$Res>
    extends _$SummaryRequestCopyWithImpl<$Res>
    implements _$$_SummaryRequestCopyWith<$Res> {
  __$$_SummaryRequestCopyWithImpl(
      _$_SummaryRequest _value, $Res Function(_$_SummaryRequest) _then)
      : super(_value, (v) => _then(v as _$_SummaryRequest));

  @override
  _$_SummaryRequest get _value => super._value as _$_SummaryRequest;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? language = freezed,
  }) {
    return _then(_$_SummaryRequest(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SummaryRequest implements _SummaryRequest {
  const _$_SummaryRequest({this.chapter, this.language});

  factory _$_SummaryRequest.fromJson(Map<String, dynamic> json) =>
      _$$_SummaryRequestFromJson(json);

  /// The chapter id e.g 1
  @override
  final int? chapter;

  /// Specify the language e.g en
  @override
  final String? language;

  @override
  String toString() {
    return 'SummaryRequest(chapter: $chapter, language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SummaryRequest &&
            const DeepCollectionEquality().equals(other.chapter, chapter) &&
            const DeepCollectionEquality().equals(other.language, language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(chapter),
      const DeepCollectionEquality().hash(language));

  @JsonKey(ignore: true)
  @override
  _$$_SummaryRequestCopyWith<_$_SummaryRequest> get copyWith =>
      __$$_SummaryRequestCopyWithImpl<_$_SummaryRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SummaryRequestToJson(
      this,
    );
  }
}

abstract class _SummaryRequest implements SummaryRequest {
  const factory _SummaryRequest({final int? chapter, final String? language}) =
      _$_SummaryRequest;

  factory _SummaryRequest.fromJson(Map<String, dynamic> json) =
      _$_SummaryRequest.fromJson;

  @override

  /// The chapter id e.g 1
  int? get chapter;
  @override

  /// Specify the language e.g en
  String? get language;
  @override
  @JsonKey(ignore: true)
  _$$_SummaryRequestCopyWith<_$_SummaryRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

SummaryResponse _$SummaryResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return SummaryResponseData.fromJson(json);
    case 'Merr':
      return SummaryResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SummaryResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SummaryResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SummaryResponseCopyWith<$Res> {
  factory $SummaryResponseCopyWith(
          SummaryResponse value, $Res Function(SummaryResponse) then) =
      _$SummaryResponseCopyWithImpl<$Res>;
}

/// @nodoc
class _$SummaryResponseCopyWithImpl<$Res>
    implements $SummaryResponseCopyWith<$Res> {
  _$SummaryResponseCopyWithImpl(this._value, this._then);

  final SummaryResponse _value;
  // ignore: unused_field
  final $Res Function(SummaryResponse) _then;
}

/// @nodoc
abstract class _$$SummaryResponseDataCopyWith<$Res> {
  factory _$$SummaryResponseDataCopyWith(_$SummaryResponseData value,
          $Res Function(_$SummaryResponseData) then) =
      __$$SummaryResponseDataCopyWithImpl<$Res>;
  $Res call({int? chapter, String? source, String? summary, String? text});
}

/// @nodoc
class __$$SummaryResponseDataCopyWithImpl<$Res>
    extends _$SummaryResponseCopyWithImpl<$Res>
    implements _$$SummaryResponseDataCopyWith<$Res> {
  __$$SummaryResponseDataCopyWithImpl(
      _$SummaryResponseData _value, $Res Function(_$SummaryResponseData) _then)
      : super(_value, (v) => _then(v as _$SummaryResponseData));

  @override
  _$SummaryResponseData get _value => super._value as _$SummaryResponseData;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? source = freezed,
    Object? summary = freezed,
    Object? text = freezed,
  }) {
    return _then(_$SummaryResponseData(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      source: source == freezed
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      summary: summary == freezed
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SummaryResponseData implements SummaryResponseData {
  const _$SummaryResponseData(
      {this.chapter, this.source, this.summary, this.text, final String? $type})
      : $type = $type ?? 'default';

  factory _$SummaryResponseData.fromJson(Map<String, dynamic> json) =>
      _$$SummaryResponseDataFromJson(json);

  /// The chapter id
  @override
  final int? chapter;

  /// The source of the summary
  @override
  final String? source;

  /// The short summary for the chapter
  @override
  final String? summary;

  /// The full description for the chapter
  @override
  final String? text;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SummaryResponse(chapter: $chapter, source: $source, summary: $summary, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SummaryResponseData &&
            const DeepCollectionEquality().equals(other.chapter, chapter) &&
            const DeepCollectionEquality().equals(other.source, source) &&
            const DeepCollectionEquality().equals(other.summary, summary) &&
            const DeepCollectionEquality().equals(other.text, text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(chapter),
      const DeepCollectionEquality().hash(source),
      const DeepCollectionEquality().hash(summary),
      const DeepCollectionEquality().hash(text));

  @JsonKey(ignore: true)
  @override
  _$$SummaryResponseDataCopyWith<_$SummaryResponseData> get copyWith =>
      __$$SummaryResponseDataCopyWithImpl<_$SummaryResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(chapter, source, summary, text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(chapter, source, summary, text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(chapter, source, summary, text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SummaryResponseDataToJson(
      this,
    );
  }
}

abstract class SummaryResponseData implements SummaryResponse {
  const factory SummaryResponseData(
      {final int? chapter,
      final String? source,
      final String? summary,
      final String? text}) = _$SummaryResponseData;

  factory SummaryResponseData.fromJson(Map<String, dynamic> json) =
      _$SummaryResponseData.fromJson;

  /// The chapter id
  int? get chapter;

  /// The source of the summary
  String? get source;

  /// The short summary for the chapter
  String? get summary;

  /// The full description for the chapter
  String? get text;
  @JsonKey(ignore: true)
  _$$SummaryResponseDataCopyWith<_$SummaryResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SummaryResponseMerrCopyWith<$Res> {
  factory _$$SummaryResponseMerrCopyWith(_$SummaryResponseMerr value,
          $Res Function(_$SummaryResponseMerr) then) =
      __$$SummaryResponseMerrCopyWithImpl<$Res>;
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$SummaryResponseMerrCopyWithImpl<$Res>
    extends _$SummaryResponseCopyWithImpl<$Res>
    implements _$$SummaryResponseMerrCopyWith<$Res> {
  __$$SummaryResponseMerrCopyWithImpl(
      _$SummaryResponseMerr _value, $Res Function(_$SummaryResponseMerr) _then)
      : super(_value, (v) => _then(v as _$SummaryResponseMerr));

  @override
  _$SummaryResponseMerr get _value => super._value as _$SummaryResponseMerr;

  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$SummaryResponseMerr(
      body: body == freezed
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SummaryResponseMerr implements SummaryResponseMerr {
  const _$SummaryResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$SummaryResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$SummaryResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SummaryResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SummaryResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  _$$SummaryResponseMerrCopyWith<_$SummaryResponseMerr> get copyWith =>
      __$$SummaryResponseMerrCopyWithImpl<_$SummaryResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, String? source, String? summary, String? text)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SummaryResponseData value) $default, {
    required TResult Function(SummaryResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SummaryResponseData value)? $default, {
    TResult Function(SummaryResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SummaryResponseMerrToJson(
      this,
    );
  }
}

abstract class SummaryResponseMerr implements SummaryResponse {
  const factory SummaryResponseMerr({final Map<String, dynamic>? body}) =
      _$SummaryResponseMerr;

  factory SummaryResponseMerr.fromJson(Map<String, dynamic> json) =
      _$SummaryResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$SummaryResponseMerrCopyWith<_$SummaryResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Translation _$TranslationFromJson(Map<String, dynamic> json) {
  return _Translation.fromJson(json);
}

/// @nodoc
mixin _$Translation {
  /// The unique id of the translation
  int? get id => throw _privateConstructorUsedError;

  /// The source of the translation
  String? get source => throw _privateConstructorUsedError;

  /// The translated text
  String? get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TranslationCopyWith<Translation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TranslationCopyWith<$Res> {
  factory $TranslationCopyWith(
          Translation value, $Res Function(Translation) then) =
      _$TranslationCopyWithImpl<$Res>;
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class _$TranslationCopyWithImpl<$Res> implements $TranslationCopyWith<$Res> {
  _$TranslationCopyWithImpl(this._value, this._then);

  final Translation _value;
  // ignore: unused_field
  final $Res Function(Translation) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: source == freezed
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_TranslationCopyWith<$Res>
    implements $TranslationCopyWith<$Res> {
  factory _$$_TranslationCopyWith(
          _$_Translation value, $Res Function(_$_Translation) then) =
      __$$_TranslationCopyWithImpl<$Res>;
  @override
  $Res call({int? id, String? source, String? text});
}

/// @nodoc
class __$$_TranslationCopyWithImpl<$Res> extends _$TranslationCopyWithImpl<$Res>
    implements _$$_TranslationCopyWith<$Res> {
  __$$_TranslationCopyWithImpl(
      _$_Translation _value, $Res Function(_$_Translation) _then)
      : super(_value, (v) => _then(v as _$_Translation));

  @override
  _$_Translation get _value => super._value as _$_Translation;

  @override
  $Res call({
    Object? id = freezed,
    Object? source = freezed,
    Object? text = freezed,
  }) {
    return _then(_$_Translation(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      source: source == freezed
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Translation implements _Translation {
  const _$_Translation({this.id, this.source, this.text});

  factory _$_Translation.fromJson(Map<String, dynamic> json) =>
      _$$_TranslationFromJson(json);

  /// The unique id of the translation
  @override
  final int? id;

  /// The source of the translation
  @override
  final String? source;

  /// The translated text
  @override
  final String? text;

  @override
  String toString() {
    return 'Translation(id: $id, source: $source, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Translation &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.source, source) &&
            const DeepCollectionEquality().equals(other.text, text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(source),
      const DeepCollectionEquality().hash(text));

  @JsonKey(ignore: true)
  @override
  _$$_TranslationCopyWith<_$_Translation> get copyWith =>
      __$$_TranslationCopyWithImpl<_$_Translation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TranslationToJson(
      this,
    );
  }
}

abstract class _Translation implements Translation {
  const factory _Translation(
      {final int? id,
      final String? source,
      final String? text}) = _$_Translation;

  factory _Translation.fromJson(Map<String, dynamic> json) =
      _$_Translation.fromJson;

  @override

  /// The unique id of the translation
  int? get id;
  @override

  /// The source of the translation
  String? get source;
  @override

  /// The translated text
  String? get text;
  @override
  @JsonKey(ignore: true)
  _$$_TranslationCopyWith<_$_Translation> get copyWith =>
      throw _privateConstructorUsedError;
}

Verse _$VerseFromJson(Map<String, dynamic> json) {
  return _Verse.fromJson(json);
}

/// @nodoc
mixin _$Verse {
  /// The interpretations of the verse
  List<Interpretation>? get interpretations =>
      throw _privateConstructorUsedError;

  /// The key of this verse (chapter:verse) e.g 1:1
  String? get key => throw _privateConstructorUsedError;

  /// The verse number in this chapter
  int? get number => throw _privateConstructorUsedError;

  /// The alternative translations for the verse
  List<Translation>? get translations => throw _privateConstructorUsedError;

  /// The individual words within the verse (Ayah)
  List<Word>? get words => throw _privateConstructorUsedError;

  /// The unique id of the verse in the whole book
  int? get id => throw _privateConstructorUsedError;

  /// The page of the Quran this verse is on
  int? get page => throw _privateConstructorUsedError;

  /// The arabic text for this verse
  String? get text => throw _privateConstructorUsedError;

  /// The basic translation of the verse
  String? get translated_text => throw _privateConstructorUsedError;

  /// The phonetic transliteration from arabic
  String? get transliteration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VerseCopyWith<Verse> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VerseCopyWith<$Res> {
  factory $VerseCopyWith(Verse value, $Res Function(Verse) then) =
      _$VerseCopyWithImpl<$Res>;
  $Res call(
      {List<Interpretation>? interpretations,
      String? key,
      int? number,
      List<Translation>? translations,
      List<Word>? words,
      int? id,
      int? page,
      String? text,
      String? translated_text,
      String? transliteration});
}

/// @nodoc
class _$VerseCopyWithImpl<$Res> implements $VerseCopyWith<$Res> {
  _$VerseCopyWithImpl(this._value, this._then);

  final Verse _value;
  // ignore: unused_field
  final $Res Function(Verse) _then;

  @override
  $Res call({
    Object? interpretations = freezed,
    Object? key = freezed,
    Object? number = freezed,
    Object? translations = freezed,
    Object? words = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? text = freezed,
    Object? translated_text = freezed,
    Object? transliteration = freezed,
  }) {
    return _then(_value.copyWith(
      interpretations: interpretations == freezed
          ? _value.interpretations
          : interpretations // ignore: cast_nullable_to_non_nullable
              as List<Interpretation>?,
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      number: number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      translations: translations == freezed
          ? _value.translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      words: words == freezed
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as List<Word>?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translated_text: translated_text == freezed
          ? _value.translated_text
          : translated_text // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: transliteration == freezed
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_VerseCopyWith<$Res> implements $VerseCopyWith<$Res> {
  factory _$$_VerseCopyWith(_$_Verse value, $Res Function(_$_Verse) then) =
      __$$_VerseCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Interpretation>? interpretations,
      String? key,
      int? number,
      List<Translation>? translations,
      List<Word>? words,
      int? id,
      int? page,
      String? text,
      String? translated_text,
      String? transliteration});
}

/// @nodoc
class __$$_VerseCopyWithImpl<$Res> extends _$VerseCopyWithImpl<$Res>
    implements _$$_VerseCopyWith<$Res> {
  __$$_VerseCopyWithImpl(_$_Verse _value, $Res Function(_$_Verse) _then)
      : super(_value, (v) => _then(v as _$_Verse));

  @override
  _$_Verse get _value => super._value as _$_Verse;

  @override
  $Res call({
    Object? interpretations = freezed,
    Object? key = freezed,
    Object? number = freezed,
    Object? translations = freezed,
    Object? words = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? text = freezed,
    Object? translated_text = freezed,
    Object? transliteration = freezed,
  }) {
    return _then(_$_Verse(
      interpretations: interpretations == freezed
          ? _value._interpretations
          : interpretations // ignore: cast_nullable_to_non_nullable
              as List<Interpretation>?,
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      number: number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      translations: translations == freezed
          ? _value._translations
          : translations // ignore: cast_nullable_to_non_nullable
              as List<Translation>?,
      words: words == freezed
          ? _value._words
          : words // ignore: cast_nullable_to_non_nullable
              as List<Word>?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      translated_text: translated_text == freezed
          ? _value.translated_text
          : translated_text // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: transliteration == freezed
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Verse implements _Verse {
  const _$_Verse(
      {final List<Interpretation>? interpretations,
      this.key,
      this.number,
      final List<Translation>? translations,
      final List<Word>? words,
      this.id,
      this.page,
      this.text,
      this.translated_text,
      this.transliteration})
      : _interpretations = interpretations,
        _translations = translations,
        _words = words;

  factory _$_Verse.fromJson(Map<String, dynamic> json) =>
      _$$_VerseFromJson(json);

  /// The interpretations of the verse
  final List<Interpretation>? _interpretations;

  /// The interpretations of the verse
  @override
  List<Interpretation>? get interpretations {
    final value = _interpretations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The key of this verse (chapter:verse) e.g 1:1
  @override
  final String? key;

  /// The verse number in this chapter
  @override
  final int? number;

  /// The alternative translations for the verse
  final List<Translation>? _translations;

  /// The alternative translations for the verse
  @override
  List<Translation>? get translations {
    final value = _translations;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The individual words within the verse (Ayah)
  final List<Word>? _words;

  /// The individual words within the verse (Ayah)
  @override
  List<Word>? get words {
    final value = _words;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The unique id of the verse in the whole book
  @override
  final int? id;

  /// The page of the Quran this verse is on
  @override
  final int? page;

  /// The arabic text for this verse
  @override
  final String? text;

  /// The basic translation of the verse
  @override
  final String? translated_text;

  /// The phonetic transliteration from arabic
  @override
  final String? transliteration;

  @override
  String toString() {
    return 'Verse(interpretations: $interpretations, key: $key, number: $number, translations: $translations, words: $words, id: $id, page: $page, text: $text, translated_text: $translated_text, transliteration: $transliteration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Verse &&
            const DeepCollectionEquality()
                .equals(other._interpretations, _interpretations) &&
            const DeepCollectionEquality().equals(other.key, key) &&
            const DeepCollectionEquality().equals(other.number, number) &&
            const DeepCollectionEquality()
                .equals(other._translations, _translations) &&
            const DeepCollectionEquality().equals(other._words, _words) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality().equals(other.text, text) &&
            const DeepCollectionEquality()
                .equals(other.translated_text, translated_text) &&
            const DeepCollectionEquality()
                .equals(other.transliteration, transliteration));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_interpretations),
      const DeepCollectionEquality().hash(key),
      const DeepCollectionEquality().hash(number),
      const DeepCollectionEquality().hash(_translations),
      const DeepCollectionEquality().hash(_words),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(text),
      const DeepCollectionEquality().hash(translated_text),
      const DeepCollectionEquality().hash(transliteration));

  @JsonKey(ignore: true)
  @override
  _$$_VerseCopyWith<_$_Verse> get copyWith =>
      __$$_VerseCopyWithImpl<_$_Verse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_VerseToJson(
      this,
    );
  }
}

abstract class _Verse implements Verse {
  const factory _Verse(
      {final List<Interpretation>? interpretations,
      final String? key,
      final int? number,
      final List<Translation>? translations,
      final List<Word>? words,
      final int? id,
      final int? page,
      final String? text,
      final String? translated_text,
      final String? transliteration}) = _$_Verse;

  factory _Verse.fromJson(Map<String, dynamic> json) = _$_Verse.fromJson;

  @override

  /// The interpretations of the verse
  List<Interpretation>? get interpretations;
  @override

  /// The key of this verse (chapter:verse) e.g 1:1
  String? get key;
  @override

  /// The verse number in this chapter
  int? get number;
  @override

  /// The alternative translations for the verse
  List<Translation>? get translations;
  @override

  /// The individual words within the verse (Ayah)
  List<Word>? get words;
  @override

  /// The unique id of the verse in the whole book
  int? get id;
  @override

  /// The page of the Quran this verse is on
  int? get page;
  @override

  /// The arabic text for this verse
  String? get text;
  @override

  /// The basic translation of the verse
  String? get translated_text;
  @override

  /// The phonetic transliteration from arabic
  String? get transliteration;
  @override
  @JsonKey(ignore: true)
  _$$_VerseCopyWith<_$_Verse> get copyWith =>
      throw _privateConstructorUsedError;
}

VersesRequest _$VersesRequestFromJson(Map<String, dynamic> json) {
  return _VersesRequest.fromJson(json);
}

/// @nodoc
mixin _$VersesRequest {
  /// The chapter id to retrieve
  int? get chapter => throw _privateConstructorUsedError;

  /// Return the interpretation (tafsir)
  bool? get interpret => throw _privateConstructorUsedError;

  /// The language of translation
  String? get language => throw _privateConstructorUsedError;

  /// The verses per page
  int? get limit => throw _privateConstructorUsedError;

  /// The page number to request
  int? get page => throw _privateConstructorUsedError;

  /// Return alternate translations
  bool? get translate => throw _privateConstructorUsedError;

  /// Return the individual words with the verses
  bool? get words => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VersesRequestCopyWith<VersesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersesRequestCopyWith<$Res> {
  factory $VersesRequestCopyWith(
          VersesRequest value, $Res Function(VersesRequest) then) =
      _$VersesRequestCopyWithImpl<$Res>;
  $Res call(
      {int? chapter,
      bool? interpret,
      String? language,
      int? limit,
      int? page,
      bool? translate,
      bool? words});
}

/// @nodoc
class _$VersesRequestCopyWithImpl<$Res>
    implements $VersesRequestCopyWith<$Res> {
  _$VersesRequestCopyWithImpl(this._value, this._then);

  final VersesRequest _value;
  // ignore: unused_field
  final $Res Function(VersesRequest) _then;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? interpret = freezed,
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? translate = freezed,
    Object? words = freezed,
  }) {
    return _then(_value.copyWith(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      interpret: interpret == freezed
          ? _value.interpret
          : interpret // ignore: cast_nullable_to_non_nullable
              as bool?,
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      translate: translate == freezed
          ? _value.translate
          : translate // ignore: cast_nullable_to_non_nullable
              as bool?,
      words: words == freezed
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
abstract class _$$_VersesRequestCopyWith<$Res>
    implements $VersesRequestCopyWith<$Res> {
  factory _$$_VersesRequestCopyWith(
          _$_VersesRequest value, $Res Function(_$_VersesRequest) then) =
      __$$_VersesRequestCopyWithImpl<$Res>;
  @override
  $Res call(
      {int? chapter,
      bool? interpret,
      String? language,
      int? limit,
      int? page,
      bool? translate,
      bool? words});
}

/// @nodoc
class __$$_VersesRequestCopyWithImpl<$Res>
    extends _$VersesRequestCopyWithImpl<$Res>
    implements _$$_VersesRequestCopyWith<$Res> {
  __$$_VersesRequestCopyWithImpl(
      _$_VersesRequest _value, $Res Function(_$_VersesRequest) _then)
      : super(_value, (v) => _then(v as _$_VersesRequest));

  @override
  _$_VersesRequest get _value => super._value as _$_VersesRequest;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? interpret = freezed,
    Object? language = freezed,
    Object? limit = freezed,
    Object? page = freezed,
    Object? translate = freezed,
    Object? words = freezed,
  }) {
    return _then(_$_VersesRequest(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      interpret: interpret == freezed
          ? _value.interpret
          : interpret // ignore: cast_nullable_to_non_nullable
              as bool?,
      language: language == freezed
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      translate: translate == freezed
          ? _value.translate
          : translate // ignore: cast_nullable_to_non_nullable
              as bool?,
      words: words == freezed
          ? _value.words
          : words // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_VersesRequest implements _VersesRequest {
  const _$_VersesRequest(
      {this.chapter,
      this.interpret,
      this.language,
      this.limit,
      this.page,
      this.translate,
      this.words});

  factory _$_VersesRequest.fromJson(Map<String, dynamic> json) =>
      _$$_VersesRequestFromJson(json);

  /// The chapter id to retrieve
  @override
  final int? chapter;

  /// Return the interpretation (tafsir)
  @override
  final bool? interpret;

  /// The language of translation
  @override
  final String? language;

  /// The verses per page
  @override
  final int? limit;

  /// The page number to request
  @override
  final int? page;

  /// Return alternate translations
  @override
  final bool? translate;

  /// Return the individual words with the verses
  @override
  final bool? words;

  @override
  String toString() {
    return 'VersesRequest(chapter: $chapter, interpret: $interpret, language: $language, limit: $limit, page: $page, translate: $translate, words: $words)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VersesRequest &&
            const DeepCollectionEquality().equals(other.chapter, chapter) &&
            const DeepCollectionEquality().equals(other.interpret, interpret) &&
            const DeepCollectionEquality().equals(other.language, language) &&
            const DeepCollectionEquality().equals(other.limit, limit) &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality().equals(other.translate, translate) &&
            const DeepCollectionEquality().equals(other.words, words));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(chapter),
      const DeepCollectionEquality().hash(interpret),
      const DeepCollectionEquality().hash(language),
      const DeepCollectionEquality().hash(limit),
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(translate),
      const DeepCollectionEquality().hash(words));

  @JsonKey(ignore: true)
  @override
  _$$_VersesRequestCopyWith<_$_VersesRequest> get copyWith =>
      __$$_VersesRequestCopyWithImpl<_$_VersesRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_VersesRequestToJson(
      this,
    );
  }
}

abstract class _VersesRequest implements VersesRequest {
  const factory _VersesRequest(
      {final int? chapter,
      final bool? interpret,
      final String? language,
      final int? limit,
      final int? page,
      final bool? translate,
      final bool? words}) = _$_VersesRequest;

  factory _VersesRequest.fromJson(Map<String, dynamic> json) =
      _$_VersesRequest.fromJson;

  @override

  /// The chapter id to retrieve
  int? get chapter;
  @override

  /// Return the interpretation (tafsir)
  bool? get interpret;
  @override

  /// The language of translation
  String? get language;
  @override

  /// The verses per page
  int? get limit;
  @override

  /// The page number to request
  int? get page;
  @override

  /// Return alternate translations
  bool? get translate;
  @override

  /// Return the individual words with the verses
  bool? get words;
  @override
  @JsonKey(ignore: true)
  _$$_VersesRequestCopyWith<_$_VersesRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

VersesResponse _$VersesResponseFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return VersesResponseData.fromJson(json);
    case 'Merr':
      return VersesResponseMerr.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'VersesResponse',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$VersesResponse {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersesResponseCopyWith<$Res> {
  factory $VersesResponseCopyWith(
          VersesResponse value, $Res Function(VersesResponse) then) =
      _$VersesResponseCopyWithImpl<$Res>;
}

/// @nodoc
class _$VersesResponseCopyWithImpl<$Res>
    implements $VersesResponseCopyWith<$Res> {
  _$VersesResponseCopyWithImpl(this._value, this._then);

  final VersesResponse _value;
  // ignore: unused_field
  final $Res Function(VersesResponse) _then;
}

/// @nodoc
abstract class _$$VersesResponseDataCopyWith<$Res> {
  factory _$$VersesResponseDataCopyWith(_$VersesResponseData value,
          $Res Function(_$VersesResponseData) then) =
      __$$VersesResponseDataCopyWithImpl<$Res>;
  $Res call({int? chapter, int? page, int? total_pages, List<Verse>? verses});
}

/// @nodoc
class __$$VersesResponseDataCopyWithImpl<$Res>
    extends _$VersesResponseCopyWithImpl<$Res>
    implements _$$VersesResponseDataCopyWith<$Res> {
  __$$VersesResponseDataCopyWithImpl(
      _$VersesResponseData _value, $Res Function(_$VersesResponseData) _then)
      : super(_value, (v) => _then(v as _$VersesResponseData));

  @override
  _$VersesResponseData get _value => super._value as _$VersesResponseData;

  @override
  $Res call({
    Object? chapter = freezed,
    Object? page = freezed,
    Object? total_pages = freezed,
    Object? verses = freezed,
  }) {
    return _then(_$VersesResponseData(
      chapter: chapter == freezed
          ? _value.chapter
          : chapter // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      total_pages: total_pages == freezed
          ? _value.total_pages
          : total_pages // ignore: cast_nullable_to_non_nullable
              as int?,
      verses: verses == freezed
          ? _value._verses
          : verses // ignore: cast_nullable_to_non_nullable
              as List<Verse>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersesResponseData implements VersesResponseData {
  const _$VersesResponseData(
      {this.chapter,
      this.page,
      this.total_pages,
      final List<Verse>? verses,
      final String? $type})
      : _verses = verses,
        $type = $type ?? 'default';

  factory _$VersesResponseData.fromJson(Map<String, dynamic> json) =>
      _$$VersesResponseDataFromJson(json);

  /// The chapter requested
  @override
  final int? chapter;

  /// The page requested
  @override
  final int? page;

  /// The total pages
  @override
  final int? total_pages;

  /// The verses on the page
  final List<Verse>? _verses;

  /// The verses on the page
  @override
  List<Verse>? get verses {
    final value = _verses;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'VersesResponse(chapter: $chapter, page: $page, total_pages: $total_pages, verses: $verses)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersesResponseData &&
            const DeepCollectionEquality().equals(other.chapter, chapter) &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality()
                .equals(other.total_pages, total_pages) &&
            const DeepCollectionEquality().equals(other._verses, _verses));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(chapter),
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(total_pages),
      const DeepCollectionEquality().hash(_verses));

  @JsonKey(ignore: true)
  @override
  _$$VersesResponseDataCopyWith<_$VersesResponseData> get copyWith =>
      __$$VersesResponseDataCopyWithImpl<_$VersesResponseData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return $default(chapter, page, total_pages, verses);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return $default?.call(chapter, page, total_pages, verses);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(chapter, page, total_pages, verses);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$VersesResponseDataToJson(
      this,
    );
  }
}

abstract class VersesResponseData implements VersesResponse {
  const factory VersesResponseData(
      {final int? chapter,
      final int? page,
      final int? total_pages,
      final List<Verse>? verses}) = _$VersesResponseData;

  factory VersesResponseData.fromJson(Map<String, dynamic> json) =
      _$VersesResponseData.fromJson;

  /// The chapter requested
  int? get chapter;

  /// The page requested
  int? get page;

  /// The total pages
  int? get total_pages;

  /// The verses on the page
  List<Verse>? get verses;
  @JsonKey(ignore: true)
  _$$VersesResponseDataCopyWith<_$VersesResponseData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VersesResponseMerrCopyWith<$Res> {
  factory _$$VersesResponseMerrCopyWith(_$VersesResponseMerr value,
          $Res Function(_$VersesResponseMerr) then) =
      __$$VersesResponseMerrCopyWithImpl<$Res>;
  $Res call({Map<String, dynamic>? body});
}

/// @nodoc
class __$$VersesResponseMerrCopyWithImpl<$Res>
    extends _$VersesResponseCopyWithImpl<$Res>
    implements _$$VersesResponseMerrCopyWith<$Res> {
  __$$VersesResponseMerrCopyWithImpl(
      _$VersesResponseMerr _value, $Res Function(_$VersesResponseMerr) _then)
      : super(_value, (v) => _then(v as _$VersesResponseMerr));

  @override
  _$VersesResponseMerr get _value => super._value as _$VersesResponseMerr;

  @override
  $Res call({
    Object? body = freezed,
  }) {
    return _then(_$VersesResponseMerr(
      body: body == freezed
          ? _value._body
          : body // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersesResponseMerr implements VersesResponseMerr {
  const _$VersesResponseMerr(
      {final Map<String, dynamic>? body, final String? $type})
      : _body = body,
        $type = $type ?? 'Merr';

  factory _$VersesResponseMerr.fromJson(Map<String, dynamic> json) =>
      _$$VersesResponseMerrFromJson(json);

  final Map<String, dynamic>? _body;
  @override
  Map<String, dynamic>? get body {
    final value = _body;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'VersesResponse.Merr(body: $body)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersesResponseMerr &&
            const DeepCollectionEquality().equals(other._body, _body));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_body));

  @JsonKey(ignore: true)
  @override
  _$$VersesResponseMerrCopyWith<_$VersesResponseMerr> get copyWith =>
      __$$VersesResponseMerrCopyWithImpl<_$VersesResponseMerr>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)
        $default, {
    required TResult Function(Map<String, dynamic>? body) Merr,
  }) {
    return Merr(body);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
  }) {
    return Merr?.call(body);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            int? chapter, int? page, int? total_pages, List<Verse>? verses)?
        $default, {
    TResult Function(Map<String, dynamic>? body)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(body);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(VersesResponseData value) $default, {
    required TResult Function(VersesResponseMerr value) Merr,
  }) {
    return Merr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
  }) {
    return Merr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(VersesResponseData value)? $default, {
    TResult Function(VersesResponseMerr value)? Merr,
    required TResult orElse(),
  }) {
    if (Merr != null) {
      return Merr(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$VersesResponseMerrToJson(
      this,
    );
  }
}

abstract class VersesResponseMerr implements VersesResponse {
  const factory VersesResponseMerr({final Map<String, dynamic>? body}) =
      _$VersesResponseMerr;

  factory VersesResponseMerr.fromJson(Map<String, dynamic> json) =
      _$VersesResponseMerr.fromJson;

  Map<String, dynamic>? get body;
  @JsonKey(ignore: true)
  _$$VersesResponseMerrCopyWith<_$VersesResponseMerr> get copyWith =>
      throw _privateConstructorUsedError;
}

Word _$WordFromJson(Map<String, dynamic> json) {
  return _Word.fromJson(json);
}

/// @nodoc
mixin _$Word {
  /// The character type e.g word, end
  String? get char_type => throw _privateConstructorUsedError;

  /// The id of the word within the verse
  int? get id => throw _privateConstructorUsedError;

  /// The page number
  int? get page => throw _privateConstructorUsedError;

  /// The position of the word
  int? get position => throw _privateConstructorUsedError;

  /// The arabic text for this word
  String? get text => throw _privateConstructorUsedError;

  /// The QCF v2 font code
  String? get code => throw _privateConstructorUsedError;

  /// The line number
  int? get line => throw _privateConstructorUsedError;

  /// The translated text
  String? get translation => throw _privateConstructorUsedError;

  /// The transliteration text
  String? get transliteration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordCopyWith<Word> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordCopyWith<$Res> {
  factory $WordCopyWith(Word value, $Res Function(Word) then) =
      _$WordCopyWithImpl<$Res>;
  $Res call(
      {String? char_type,
      int? id,
      int? page,
      int? position,
      String? text,
      String? code,
      int? line,
      String? translation,
      String? transliteration});
}

/// @nodoc
class _$WordCopyWithImpl<$Res> implements $WordCopyWith<$Res> {
  _$WordCopyWithImpl(this._value, this._then);

  final Word _value;
  // ignore: unused_field
  final $Res Function(Word) _then;

  @override
  $Res call({
    Object? char_type = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? position = freezed,
    Object? text = freezed,
    Object? code = freezed,
    Object? line = freezed,
    Object? translation = freezed,
    Object? transliteration = freezed,
  }) {
    return _then(_value.copyWith(
      char_type: char_type == freezed
          ? _value.char_type
          : char_type // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      position: position == freezed
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
      translation: translation == freezed
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: transliteration == freezed
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_WordCopyWith<$Res> implements $WordCopyWith<$Res> {
  factory _$$_WordCopyWith(_$_Word value, $Res Function(_$_Word) then) =
      __$$_WordCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? char_type,
      int? id,
      int? page,
      int? position,
      String? text,
      String? code,
      int? line,
      String? translation,
      String? transliteration});
}

/// @nodoc
class __$$_WordCopyWithImpl<$Res> extends _$WordCopyWithImpl<$Res>
    implements _$$_WordCopyWith<$Res> {
  __$$_WordCopyWithImpl(_$_Word _value, $Res Function(_$_Word) _then)
      : super(_value, (v) => _then(v as _$_Word));

  @override
  _$_Word get _value => super._value as _$_Word;

  @override
  $Res call({
    Object? char_type = freezed,
    Object? id = freezed,
    Object? page = freezed,
    Object? position = freezed,
    Object? text = freezed,
    Object? code = freezed,
    Object? line = freezed,
    Object? translation = freezed,
    Object? transliteration = freezed,
  }) {
    return _then(_$_Word(
      char_type: char_type == freezed
          ? _value.char_type
          : char_type // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      page: page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int?,
      position: position == freezed
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int?,
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
      translation: translation == freezed
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as String?,
      transliteration: transliteration == freezed
          ? _value.transliteration
          : transliteration // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Word implements _Word {
  const _$_Word(
      {this.char_type,
      this.id,
      this.page,
      this.position,
      this.text,
      this.code,
      this.line,
      this.translation,
      this.transliteration});

  factory _$_Word.fromJson(Map<String, dynamic> json) => _$$_WordFromJson(json);

  /// The character type e.g word, end
  @override
  final String? char_type;

  /// The id of the word within the verse
  @override
  final int? id;

  /// The page number
  @override
  final int? page;

  /// The position of the word
  @override
  final int? position;

  /// The arabic text for this word
  @override
  final String? text;

  /// The QCF v2 font code
  @override
  final String? code;

  /// The line number
  @override
  final int? line;

  /// The translated text
  @override
  final String? translation;

  /// The transliteration text
  @override
  final String? transliteration;

  @override
  String toString() {
    return 'Word(char_type: $char_type, id: $id, page: $page, position: $position, text: $text, code: $code, line: $line, translation: $translation, transliteration: $transliteration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Word &&
            const DeepCollectionEquality().equals(other.char_type, char_type) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.page, page) &&
            const DeepCollectionEquality().equals(other.position, position) &&
            const DeepCollectionEquality().equals(other.text, text) &&
            const DeepCollectionEquality().equals(other.code, code) &&
            const DeepCollectionEquality().equals(other.line, line) &&
            const DeepCollectionEquality()
                .equals(other.translation, translation) &&
            const DeepCollectionEquality()
                .equals(other.transliteration, transliteration));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(char_type),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(page),
      const DeepCollectionEquality().hash(position),
      const DeepCollectionEquality().hash(text),
      const DeepCollectionEquality().hash(code),
      const DeepCollectionEquality().hash(line),
      const DeepCollectionEquality().hash(translation),
      const DeepCollectionEquality().hash(transliteration));

  @JsonKey(ignore: true)
  @override
  _$$_WordCopyWith<_$_Word> get copyWith =>
      __$$_WordCopyWithImpl<_$_Word>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WordToJson(
      this,
    );
  }
}

abstract class _Word implements Word {
  const factory _Word(
      {final String? char_type,
      final int? id,
      final int? page,
      final int? position,
      final String? text,
      final String? code,
      final int? line,
      final String? translation,
      final String? transliteration}) = _$_Word;

  factory _Word.fromJson(Map<String, dynamic> json) = _$_Word.fromJson;

  @override

  /// The character type e.g word, end
  String? get char_type;
  @override

  /// The id of the word within the verse
  int? get id;
  @override

  /// The page number
  int? get page;
  @override

  /// The position of the word
  int? get position;
  @override

  /// The arabic text for this word
  String? get text;
  @override

  /// The QCF v2 font code
  String? get code;
  @override

  /// The line number
  int? get line;
  @override

  /// The translated text
  String? get translation;
  @override

  /// The transliteration text
  String? get transliteration;
  @override
  @JsonKey(ignore: true)
  _$$_WordCopyWith<_$_Word> get copyWith => throw _privateConstructorUsedError;
}
